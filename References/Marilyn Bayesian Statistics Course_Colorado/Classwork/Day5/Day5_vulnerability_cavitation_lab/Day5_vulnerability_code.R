####
####	To help with coming-up with starting values for alpha & beta:
####  Solve for parameters in gamma distributions for location-level
####	parameters given estimates of val50["P50"] and val50["S50"]
####	via the optim function (i.e., find values of alpha & beta that
####	minimized sum of squared differences between the "predicted"
####  S50 and P50 (fP50, fS50) versus reasonable estimates of each
####	(in val50)
#### 
setwd("C:\\Users\\MBrandt\\Dropbox\\Transfer documents\\conferences\\Bayesian Statistics\\Classwork\\Day5\\Day5_vulnerability_cavitation_lab\\")

fcn2 <- function(theta,val50){
	alpha=theta[1]
	beta=theta[2]
	fP50 <- alpha*(log(2)^(1/beta))
	fS50 <- (beta/val50["P50"])*exp(-((val50["P50"]/alpha)^beta))*((val50["P50"]/alpha)^beta)
	f <- (fP50 - val50["P50"])^2 + (fS50 -  val50["S50"])^2
	f
}

## Optimize will find the solutions to alpha and beta that minimize
## the "squared error loss function" defined in fcn2:
optim(c(2,5),fcn2,val50=c(P50=5,S50=0.10))$par



#### Load rjags and xtable libraries
library(rjags)
library(xtable)

#### Read in cavitation data:
y=(read.csv("CavitationData.csv"))

#### Define data to be used in model, including "sample/group" sizes
tree_data= list(N = 12, M = 9, Nloc = 2,
				loc=y[,2],
				Ks = as.matrix(y[,12:ncol(y)]),
				P = as.matrix(y[,3:11])
				)

#### Set initial conditions to initial MCMC chains. Will run 3 chains,
#### so provide 3 lists of starting values for all ROOT nodes.
#### See beginning of script (optim function) to help with coming-up
#### with starting values for E.alpha and E.beta.

inits = list(
  list(E.beta=c(5,5), E.alpha=c(2,2), E.ksat=c(1,1),
       sig.beta=1, sig.alpha = 1, sig.ksat =0.10, tau = 100),
  list(E.beta=c(4,6), E.alpha=c(1,3), E.ksat=c(1.1,1.1),
       sig.beta=0.5, sig.alpha = 0.5, sig.ksat =0.020, tau = 200),
  list(E.beta=c(7,3), E.alpha=c(3,6), E.ksat=c(.9,.9),
       sig.beta=0.02, sig.alpha = 0.010, sig.ksat =0.0050, tau = 500))

#### Set n.adapt (i.e., number of initial iterations for adapting
#### phase, if JAGS uses, e.g., Metropolis-Hastings); set n.iter
#### (i.e., the number of iterations to run after adapting).
n.adapt=1000
n.iter=5000

#### Set-up the MCMC procedure by specifying the file that contains
#### the model code (be sure to specify the name of YOUR model file),
#### indicate the data, indicate the initials, indicate the number of 
#### chains (i.e., the number of lists in the list of lists of starting
#### values), specify the length of the adapting phase.
jm=jags.model("Day5_vulnerability_JAGS_STARTER_CODE.R",
  data=tree_data,
  inits=inits,
  n.chains=length(inits),
  n.adapt=n.adapt)

#### Run the MCMC chains and store the sample obtained for those
#### variables.names specified.  Possbile quantities to monitor:
#### deviance, beta, alpha, ksat, P50, S50, E.ksat, E.P50, E.S50, sigs
#### Can create either a coda object or a jags object. If create both,
#### then means that you will rerun the model twice. 
#### Need to load.module("dic") so we can monitor deviance, which will
#### provide an overall evalation of "how the MCMC procedure is doing"

#### Here we will just use coda.samples so we can use coda directly,
#### which has many more diagnotic functions than can be used
#### on objects returned by jags.samples.  But, you could create JAGS
#### objects and convert them to coda objects as described in Tom's
#### JAGS primer

load.module("dic")
zc = coda.samples(jm,variable.names=c("sigs","deviance","beta","alpha",
                       "ksat","P50","S50","E.ksat","E.P50","E.S50"),
  n.iter=n.iter)

#### History (or trace) plots of sampled parameters:
plot(zc, ask=TRUE)

#### Gelman-Rubin convergence diagnotics (want r < 1.2)
gelman.diag(zc) 

### Some use functions before getting "windows" of samples
### Should be self explanatory.  See e.g., end.mcmc or
### end.mcmc.list in coda help files.
st=start(zc)
en=end(zc) 
th=thin(zc)

## EG 1 (same as default)
plot(window(zc, start=1001, end=6000, thin=1), ask=TRUE)
#This plots the overall deviance - a good summary of the overall fit of the model


#### Pick specific quantities to plot, such as E.P50[1] for location 1, and
#### E.P50[2] for location 2.
plot(window(zc, start=st, end=en, thin=1)[,c("E.P50[1]", "E.P50[2]")], ask=TRUE)
xyplot(window(zc, start=st, end=en, thin=1)[,c("E.P50[1]", "E.P50[2]")], ask=TRUE)
#Can also plot for S50
xyplot(window(zc, start=st, end=en, thin=1)[,c("E.ksat[1]", "E.ksat[2]")], ask=TRUE)
#Tree level ksats:
xyplot(window(zc, start=st, end=en, thin=1)[,c("ksat[1]", "ksat[2]", "ksat[3]")], ask=TRUE)

densityplot(window(zc, start=st, end=en, thin=1)[,c("E.P50[1]", "E.P50[2]")], ask=TRUE)

#### Pick specific quantities to plot, such as E.P50[1] for location 1, and
#### E.P50[2] for location 2, but allow for possible burn-in of an addition 
#### bi iterations after the adapting phase:
bi = 2000
plot(window(zc, start=st+bi, end=en, thin=1)[,c("E.P50[1]", "E.P50[2]")], ask=TRUE)
xyplot(window(zc, start=st+bi, end=en, thin=1)[,c("E.P50[1]", "E.P50[2]")], ask=TRUE)
densityplot(window(zc, start=st+bi, end=en, thin=1)[,c("E.P50[1]", "E.P50[2]")], ask=TRUE)

#### Recreate plots after thinning chains and removing burn-in, e.g:
plot(window(zc, start=st+bi, end=en, thin=100)[,c("E.P50[1]", "E.P50[2]")],ask=TRUE)

#### Produce posterior summary statistics
table1=summary(zc)$stat
table2=summary(zc)$quantiles

###From table1: 
#Mean for location 1: 7.65
#Mean for location 2: 9.23
#95% credible interval for location 1: 6.32, 9.04 
#95% credible interval for location 2: 7.90, 10.66
#The credible interval for location 1 does not contain location 2's mean
#The credible interval for location 2 does not contain location 1's mean

#Could also do contrast within code: diff = P50[1]-P50[2] and see if it contains 0.
# this is the more credible way to report, in case the two are correlated.

