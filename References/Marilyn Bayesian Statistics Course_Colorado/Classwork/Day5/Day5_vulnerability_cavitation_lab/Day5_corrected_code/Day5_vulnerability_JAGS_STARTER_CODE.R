model{
	# Define the likelihood of the relative conductivity data (Ks)
	# Each relative conductivity measurement on segment i is distributed
	# as normal with mean mu and precision tau (std dev = sig = 1/sqrt(tau)).
	for(i in 1:N){ # N=total number of trees
		for(m in 1:M){ # M=number of repeated measurements per stem
			# Likelihood for observed data:
			Ks[i,m] ~ dnorm(mu[i,m],tau)

			# Define plc according to Weibull cdf, and compute mu given 
			# our model for plc. The parameters (alpha, beta, ksat) should
			# vary by tree (i):
			plc[i,m] <- 1 - exp(-p1[i,m])
			p1[i,m] <- pow(P[i,m]/alpha[i], beta[i])
			#mu[i,m] <- ????
			mu[i,m] <- ksat[i]-(plc[i,m])*ksat[i])
		}
		
		# Assign semi-informative prior to the initial, unknown pressure
		#P[i,1] ~ ????		
		P[i,1] ~ dunif(0,2)

		# Hierarhical gamma priors for tree-level parameters, where their
		# gamma distributions depend on location-level parameters (e.g.,
		# a.beta, a.alpha,...,b.alpha, b.ksat):
		beta[i] ~ dgamma(a.beta[loc[i]], b.beta[loc[i]])
		alpha[i] ~ dgamma(a.alpha[loc[i]],b.alpha[loc[i]])
		ksat[i] ~ dgamma(a.ksat[loc[i]],b.ksat[loc[i]])
		# Compute tree-level quantities of interest (P50, S50):		
		P50[i] <- alpha[i]*pow(log(2),1/beta[i])
		#S50[i[ <- ???????
		S50[i] <- (beta[i]/P50[i])*(exp((-pow(P50[i]/alpha[i],beta[i]))*(pow(P50[i]/alpha[i],beta[i])))
	}


	# Relatively non-informative, independent priors for location-level parameters:
	for(i in 1:Nloc){
		# Hierarchical, relativley non-informative gamma priors for location-level 
		# parameters representing the first moment (i.e., means) of corresponding 
		# tree-level distribution parameters:	
		E.beta[i] ~ dgamma(0.01,0.01)
		E.alpha[i] ~ dgamma(0.01,0.01)
		E.ksat[i] ~ dgamma(0.01,0.01)
		
		# Via moment matching, compute gamma shape (a) and rate (b) parameters for
		# the location-level parameters:		
		a.beta[i] <- pow(E.beta[i],2)/V.beta
		b.beta[i] <- E.beta[i]/V.beta

		a.alpha[i] <- pow(E.alpha[i],2)/V.alpha
		b.alpha[i] <- E.alpha[i]/V.alpha

		a.ksat[i] <- pow(E.ksat[i],2)/V.ksat
		b.ksat[i] <- E.ksat[i]/V.ksat
		
		# Compute location-level quantities of interest (P50, S50):		
		E.P50[i] <- E.alpha[i]*pow(log(2),1/E.beta[i])
		E.S50[i] <- (E.beta[i]/E.P50[i])*(exp((-pow(E.P50[i]/E.alpha[i],E.beta[i]))*(pow(E.P50[i]/E.alpha[i],E.beta[i])))
	}

	# Assign relatively non-informative, independent priors to all standard deviation terms
	# and compute associated precision and variance:
	tau ~ dgamma(0.01, 0.01)
	sig <- 1/sqrt(tau)
	# Uniform priors for standard deviations associated with hierarchical gamma priors
	sig.beta ~ dunif(0,100)
	sig.alpha ~ dunif(0,100)
	sig.ksat ~ dunif(0,100)
	# Compute associated variances for hierarchical gamma priors	
	V.beta <- pow(sig.beta,2)  #Does not have an index because this is a parent node
	V.alpha <- pow(sig.alpha,2)
	V.ksat <- pow(sig.ksat,2)
	# Store all standard deviations in one vector:	
	sigs[1] <- sig
	sigs[2] <- sig.beta
	sigs[3] <- sig.alpha
	sigs[4] <- sig.ksat					
}
