#### Load rjags and xtable libraries
library(rjags)
library(xtable)

#### Read in cavitation data:
y=(read.csv("CavitationData.csv"))

#### Define data to be used in model, including "sample/group" sizes
tree_data= list(N = 12, M = 9, Nloc = 2,
				loc=y[,2],
				Ks = as.matrix(y[,12:ncol(y)]),
				P = as.matrix(y[,3:11])
				)

#### Set initial conditions to initial MCMC chains. Will run 3 chains,
#### so provide 3 lists of starting values for all ROOT nodes.
################################################################
#### NOTE: need to include starting values for sigO and sigP
################################################################

inits = list(
  list(E.beta=c(5,5), E.alpha=c(2,2), E.ksat=c(1,1),
       sig.beta=1, sig.alpha = 1, sig.ksat =0.10, sigO = 0.1, sigP=0.1),
  list(E.beta=c(4,6), E.alpha=c(1,3), E.ksat=c(1.1,1.1),
       sig.beta=0.5, sig.alpha = 0.5, sig.ksat =0.020, sigO = 0.05, sigP = 0.05),
  list(E.beta=c(7,3), E.alpha=c(3,6), E.ksat=c(.9,.9),
       sig.beta=0.02, sig.alpha = 0.010, sig.ksat =0.0050, sigO = 0.2, sigP = 0.03))

#### Set n.adapt (i.e., number of initial iterations for adapting
#### phase, if JAGS uses, e.g., Metropolis-Hastings); set n.iter
#### (i.e., the number of iterations to run after adapting).
n.adapt=1000
n.iter=25000
n.chains = length(inits)

#### Set-up the MCMC procedure for MODEL 1 by specifying the file that 
#### contains the model code (be sure to specify the name of YOUR model 
#### file), indicate the data, indicate the initials, indicate the number 
#### of chains (i.e., the number of lists in the list of lists of starting
#### values), specify the length of the adapting phase.
#####################################################################
#### NOTE: need to specify the file name that contains the JAGS code
#####################################################################

jm1=jags.model("Day6_JAGS_model1_SOLUTIONS.R",
  data=tree_data,
  inits=inits,
  n.chains=n.chains,
  n.adapt=n.adapt)

#### Run the MCMC chains and store the sample obtained for those
#### variables.names specified.  Possible quantities to monitor:
#### deviance, beta, alpha, ksat, P50, S50, E.ksat, E.P50, E.S50, sigs
#### Can create either a coda object or a jags object. If create both,
#### then this means that you will rerun the model twice. 
#### Need to load.module("dic") so we can monitor deviance, which will
#### provide an overall evalation of "how the MCMC procedure is doing"

#### Here we will just use coda.samples so we can use coda directly,
#### which has many more diagnotic functions than can be used
#### on objects returned by jags.samples.  But, you could create JAGS
#### objects and convert them to coda objects as described in Tom's
#### JAGS primer

load.module("dic")
zc1 = coda.samples(jm1,variable.names=c("sigs","deviance","beta","alpha",
                       "ksat","P50","S50","E.ksat","E.P50","E.S50"),
  n.iter=n.iter)

#### With below command, R will ask you to hit enter to show each page of 
#### output/graphics:
devAskNewPage(ask = TRUE)

#### For ease of coding, create variables that indicate the start and end
#### iterations for the MCMC chains associated with the zc1 coda object:
st=start(zc1)
en=end(zc1) 
th=thin(zc1)

#### View trace plots of each monitored quantity:
xyplot(window(zc1, start=st, end=en, thin=1),layout=c(2,4))
#### View density plots of each monitored quantity:
densityplot(window(zc1, start=st, end=en, thin=1), layout=c(2,4))

#### Or, could use the Windows command (often used for working with time-series 
#### data) to pick specific quantities to plot, such as E.P50[1] for location 1,
#### and E.P50[2] for location 2.
# plot(window(zc1, start=st, end=en, thin=1)[,c("E.P50[1]", "E.P50[2]")], ask=TRUE)
# xyplot(window(zc1, start=st, end=en, thin=1)[,c("E.P50[1]", "E.P50[2]")], ask=TRUE)
# densityplot(window(zc1, start=st, end=en, thin=1)[,c("E.P50[1]", "E.P50[2]")], ask=TRUE)

#### Again for sigs: 
# xyplot(window(zc1, start=st, end=en, thin=1)[,c("sigs[1]","sigs[2]","sigs[3]","sigs[4]","sigs[5]")], layout=c(2,4))
#### Above is the same as:
# xyplot(window(zc1, start=st, end=en, thin=1)[,paste("sigs[",1:5,"]",sep="")], layout=c(2,4))


#### Gelman-Rubin convergence diagnotics (want r < 1.2)
gelman.plot(zc1, layout=c(2,4))
gelman.diag(zc1)


#### Again, pick-off specific quantities to plot, such as E.P50[1] for location 1, 
#### and E.P50[2] for location 2, but allow for possible burn-in of an additional 
#### bi iterations after the adapting phase:
bi = 1000
plot(window(zc1, start=st+bi, end=en, thin=1)[,c("E.P50[1]", "E.P50[2]")])
xyplot(window(zc1, start=st+bi, end=en, thin=1)[,c("E.P50[1]", "E.P50[2]")])
densityplot(window(zc1, start=st+bi, end=en, thin=1)[,c("E.P50[1]", "E.P50[2]")])

#### If there is a burn-in period and notable within chain autocorrelation, then
#### can recreate plots after thinning chains and removing burn-in, e.g:
plot(window(zc1, start=st+bi, end=en, thin=10)[,c("E.P50[1]", "E.P50[2]")])

#### Look at within chain autocorrelation to determine how long to run the
#### chains (i.e., determined by degree of within chain autocorrelation):
autocorr.plot(window(zc1, start=st+bi, end=en, thin=1),lag.max=30)
#### Compute within chain autocorrelation coefficients at specific lags:
autocorr(window(zc1, start=st+bi, end=en, thin=1), lags = c(5, 10, 25, 50), relative=FALSE)

#### Produce posterior summary statistics; discard burn-in and thin samples
#### Should thin some quantities by more than 10 due to excessive within
#### chain autocorrelation (thinning necessary for getting unbiased posterior
#### standard deviations or variances, but not necessary for getting posterior
#### means or quantiles). Thin by 10 here for demo purposes.
n.thin = 10
table1=summary(window(zc1, start=st+bi, end=en, thin=n.thin))$stat
table2=summary(window(zc1, start=st+bi, end=en, thin=n.thin))$quantiles

#### Number of MCMC samples per quantity/parameter used to compute
#### posterior stats
Nsamples = n.chains*((en-(st+bi))/n.thin)


#### Save state from MODEL 1 (i.e. grab last MCMC-sampled values of each
#### paramter), which we will use to initiate MODEL 2.
#### There are potentially two (easy) ways to save state for use as
#### starting values for subsequent iterations:
#### (1) "user servicable way" (doesn't return RNG type(s)/seed(s)),
#### which appears to work with both the coda object (so, can get last
#### values in the MCMC chains) or the JAGS model object (so, get 
#### values at the end of the adapting phase):
jstate <- list(coef(zc1, chain=1), coef(zc1, chain=2), coef(zc1, chain=3))
# jstate <- list(coef(jm, chain=1), coef(jm, chain=2), coef(jm, chain=3))


#### (2) OR use the state function in the jags/coda object with
#### "internal=TRUE" to return the same as above plus RNG type(s) and
#### seed(s), which, supposedly, can be used to put the chain(s),
#### including rng seed/state, "exactly back on track" for
#### reproducability.  (I have not checked that this actually happens
#### (i.e., start multiple times at same list value (with rng
#### seed/state) and see if get exactly the same results.)). But,
#### appears to only work with the JAGS model object, so this would
#### grap the MCMC samples at the end of the adapting phase.
# jstate <- jm$state(internal=TRUE)

#### Create bivariate scatter plots for select parameters. First, 
#### create a data matrix that contains the MCMC output for the 
#### selected parameters; thin the MCMC chains to reduce the 
#### time required to render the plot. Create the scatter plots
#### (via pairs) and compute correlations (via cor) between each
#### parameter in the plot.mat data matrix:
plot.mat<- as.matrix(window(zc1, start=st+bi,
                            end=en, thin=20)[,paste("sigs[",1:5,"]",
                                      sep="")])
pairs(plot.mat)
cor(plot.mat)

###################################################################
####
####  Now modify the MODEL 1 JAGS code to create a new JAGS
####  model for MODEL 2. Then, run MODEL 2.
####
###################################################################


#### First, run MODEL 2 using the same initials as used for MODEL 1
#### (see above). 

jm2=jags.model("Day6_JAGS_model2_SOLUTIONS.R",
  data=tree_data,
  inits=inits,
  n.chains=n.chains,
  n.adapt=n.adapt)

#### Above approach for initializing MODEL 2 is likely to fail. 
#### So, try initializing MODEL 2 with the save states from MODEL 1:

jm2=jags.model("Day6_JAGS_model2_SOLUTIONS.R",
  data=tree_data,
  inits=jstate,
  n.chains=n.chains,
  n.adapt=n.adapt)

zc2 = coda.samples(jm2,variable.names=c("sigs","deviance","beta","alpha",
                       "ksat","P50","S50","E.ksat","E.P50","E.S50"),
  n.iter=n.iter)

#### Repeat above trace plots, autocorrelation plots, and bivariate 
#### scatter plots based on Model 2 output. In particular, look at 
#### deviance and sigO and sigP (elements of the sigs).
