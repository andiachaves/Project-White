setwd("C:\\Users\\MBrandt\\Dropbox\\Transfer documents\\conferences\\Bayesian Statistics\\Classwork\\Day6\\Day6_AM_Lab\\")
#### Load rjags and xtable libraries
library(rjags)
library(xtable)


#### Read in cavitation data:
y=(read.csv("CavitationData.csv"))

#### Define data to be used in model, including "sample/group" sizes
tree_data= list(N = 12, M = 9, Nloc = 2,
				loc=y[,2],
				Ks = as.matrix(y[,12:ncol(y)]),
				P = as.matrix(y[,3:11])
				)

#### Set initial conditions to initial MCMC chains. Will run 3 chains,
#### so provide 3 lists of starting values for all ROOT nodes.
################################################################
#### NOTE: need to include starting values for sigO and sigP.
#### Fill-in arguments for ????
################################################################

inits = list(
  list(E.beta=c(5,5), E.alpha=c(2,2), E.ksat=c(1,1),
       sig.beta=1, sig.alpha = 1, sig.ksat =0.10, sig0 = 0.1, sigP = 0.1),
  list(E.beta=c(4,6), E.alpha=c(1,3), E.ksat=c(1.1,1.1),
       sig.beta=0.5, sig.alpha = 0.5, sig.ksat =0.020, sig0 = 0.05, sigP = 0.05),
  list(E.beta=c(7,3), E.alpha=c(3,6), E.ksat=c(.9,.9),
       sig.beta=0.02, sig.alpha = 0.010, sig.ksat =0.0050, sig0 = 0.02, sigP = 0.03))
###Why the choice of the initial settings? - based on looking at the data

#### Set n.adapt (i.e., number of initial iterations for adapting
#### phase, if JAGS uses, e.g., Metropolis-Hastings); set n.iter
#### (i.e., the number of iterations to run after adapting).
n.adapt=1000
n.iter=25000
n.chains = length(inits)

#### Set-up the MCMC procedure for MODEL 1 by specifying the file that 
#### contains the model code (be sure to specify the name of YOUR model 
#### file), indicate the data, indicate the initials, indicate the number 
#### of chains (i.e., the number of lists in the list of lists of starting
#### values), specify the length of the adapting phase.
#####################################################################
#### NOTE: need to specify the file name that contains the JAGS code
#### Fill-in arguments for ????
################################################################

jm1=jags.model("Day6_JAGS_model1_STARTER_CODE.R",
  data=tree_data,
  inits=inits,
  n.chains=n.chains,
  n.adapt=n.adapt)

#### Run the MCMC chains and store the sample obtained for those
#### variables.names specified.  Quantities to monitor:
#### deviance, beta, alpha, ksat, P50, S50, E.ksat, E.P50, E.S50, sigs
#### Can create a coda object and also load.module("dic") so we can
#### monitor deviance.

load.module("dic")
zc1 = coda.samples(jm1,variable.names=c("sigs","deviance", "beta", "alpha", "ksat", "P50", "S50", "E.ksat", "E.P50", "E.S50"),
  n.iter=n.iter)

#### With below command, R will ask you to hit enter to show each page of 
#### output/graphics:
devAskNewPage(ask = TRUE)

#### For ease of coding, create variables that indicate the start and end
#### iterations for the MCMC chains associated with the zc1 coda object:
st=start(zc1)
en=end(zc1) 
th=thin(zc1)

#### View trace plots of each monitored quantity:
xyplot(window(zc1, start=st, end=en, thin=1),layout=c(2,4))
#### View density plots of each monitored quantity:
densityplot(window(zc1, start=st, end=en, thin=1), layout=c(2,4))

#### Or, could use the Windows command (often used for working with time-series 
#### data) to pick specific quantities to plot, such as E.P50[1] for location 1,
#### and E.P50[2] for location 2. See solutions and examples below.

#### Gelman-Rubin convergence diagnotics (want r < 1.2)
gelman.plot(zc1, layout=c(2,4))
gelman.diag(zc1)


#### Again, pick-off specific quantities to plot, such as E.P50[1] for location 1, 
#### and E.P50[2] for location 2, but allow for possible burn-in of an additional 
#### bi iterations after the adapting phase:
bi = 1000
plot(window(zc1, start=st+bi, end=en, thin=1)[,c("E.P50[1]", "E.P50[2]")])
xyplot(window(zc1, start=st+bi, end=en, thin=1)[,c("E.P50[1]", "E.P50[2]")])
densityplot(window(zc1, start=st+bi, end=en, thin=1)[,c("E.P50[1]", "E.P50[2]")])

#### Look at within chain autocorrelation to determine how long to run the
#### chains (i.e., determined by degree of within chain autocorrelation):
autocorr.plot(window(zc1, start=st+bi, end=en, thin=1),lag.max=30)
#### Compute within chain autocorrelation coefficients at specific lags:
autocorr(window(zc1, start=st+bi, end=en, thin=1), lags = c(5, 10, 25, 50), relative=FALSE)

#### If there's a burn-in period (length bi) and notable within chain autocorrelation, 
#### then can recreate plots after thinning chains and removing burn-in, e.g:
bi = 1000
xyplot(window(zc1, start=st+bi, end=en, thin=10),layout=c(2,4))
densityplot(window(zc1, start=st+bi, end=en, thin=10), layout=c(2,4))

#### Produce posterior summary statistics; discard burn-in and thin samples
#### Should thin some quantities by more than 10 due to excessive within
#### chain autocorrelation (thinning necessary for getting unbiased posterior
#### standard deviations or variances, but not necessary for getting posterior
#### means or quantiles). Excessive within chain autocorrelation, however,
#### means that we need to run the chains longer. 
#### Thin by 10 here for demo purposes.
n.thin = 10
table1=summary(window(zc1, start=st+bi, end=en, thin=n.thin))$stat
table2=summary(window(zc1, start=st+bi, end=en, thin=n.thin))$quantiles

#### Number of MCMC samples per quantity/parameter used to compute
#### posterior stats
Nsamples = n.chains*((en-(st+bi))/n.thin)


#### Save state from MODEL 1 (i.e. grab last MCMC-sampled values of each
#### paramter), which we will use to initiate MODEL 2.
#### There are potentially two ways to save state for use as
#### starting values for subsequent iterations. See the solutions for 
#### the alternative way that uses jm$state
jstate <- list(coef(zc1, chain=1), coef(zc1, chain=2), coef(zc1, chain=3))

#### Create bivariate scatter plots for select parameters. First, create a 
#### data matrix that contains the MCMC output for the selected parameters; 
#### thin the MCMC chains to reduce the time required to render the plot.
#### Create the scatter plots (via pairs) and compute correlations (via cor) 
#### between each parameter in the plot.mat data matrix:
plot.mat<- as.matrix(window(zc1, start=st+bi,
                            end=en, thin=20)[,paste("sigs[",1:5,"]",
                                      sep="")])
pairs(plot.mat)
cor(plot.mat)

###################################################################
####
####  Now modify the MODEL 1 JAGS code to create a new JAGS
####  model for MODEL 2. Then, run MODEL 2.
####
###################################################################


#### First, run MODEL 2 using the same initials as used for MODEL 1
#### (see above). 
################################################################
#### Fill-in arguments for ????
################################################################

jm2=jags.model("Day6_JAGS_model2_SOLUTIONS.R",
  data=tree_data,
  inits=inits,
  n.chains=n.chains,
  n.adapt=n.adapt)

#### Above approach for initializing MODEL 2 is likely to fail. 
#### So, try initializing MODEL 2 with the save states from MODEL 1:

jm2=jags.model("Day6_JAGS_model2_SOLUTIONS.R",
  data=tree_data,
  inits=jstate,
  n.chains=n.chains,
  n.adapt=n.adapt)

##STOPPED HERE BECAUSE JSTATE WAS NULL********************************************************************
##Would not choose model 2 


zc2 = coda.samples(????,variable.names=c("sigs","deviance","beta","alpha",
                       "ksat","P50","S50","E.ksat","E.P50","E.S50"),
  n.iter=n.iter)

#### Repeat above trace plots, autocorrelation plots, and bivariate 
#### scatter plots based on Model 2 output. In particular, look at 
#### deviance and sigO and sigP (elements of the sigs).
