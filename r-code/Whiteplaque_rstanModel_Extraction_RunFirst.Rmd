---
title: "Extraction from posterior"
author: "Bernd Panassiti"
date: 'created: 26.07.2017, last modified: `r format(Sys.Date(), format="%d.%m.%Y")`'
output: html_document
header-includes: \usepackage{graphicx}
---

## Introduction
Script extracts necessary data to create diagnositic plots for the RStan model for White plaque disease.
Needs as input the stan.white object.  


## Initial setup
```{r setup, include=FALSE, warnings=FALSE}
library(knitr)
opts_knit$set(root.dir='../')       # definining working directory; or normalizePath('../')
opts_chunk$set(fig.align='center',   # aligns all figures
                echo=FALSE,          # suppresses r-code
                message=FALSE,       # suppresses library outputs
                warnings=FALSE,      # suppresses library outputs
                dev='pdf')           # pdf device
```

```{r load}
rm(list=ls(all=TRUE))

set.seed(123)

# load settings, data & libraries
source("r-code/00_settings.r")
source("r-code/00_helper_functions.r")

# unload all packages in "other attached packages"
sessionInfo()
#detach("package:",unload=T)

library(plyr) # aplyr (function:stanGraphInput)
library(rstan) # extraction of posterior, function:stanGraphInput
library(MCMCpack) # rwish function, to create mmcmc list, function:stanGraphInput
library(zoo) # rollapply

#devtools::install_github(repo = "DHARMa", username = "florianhartig", subdir = "DHARMa", dependencies = T, build_vignettes = TRUE)
library(DHARMa)

#Load files workingdata and stan file with the results of the model
load(file="data/Whiteplague_workingdata.Rdata")

NameOfModelRun <- ""
load(file=paste("data/",NameOfModelRun,".Rdata",sep=""))
```

## Data preparation for graphs

### Define Observed data
```{r ObsPred,,echo=FALSE}
observedWhitePlaque<-Whiteplague_workingdata$Plague
```



### Extraction of coefficients from stan object
```{r Whiteplaque_graph_input}
GraphInput<-stanGraphInput(stan.white2) # reguires libraries: rstan, MCMCpack, plyr
```


```{r Extract_posterior}
# # extract entire posterior; all parameters
posterior<-extract(stan.white,inc_warmup=F,permute=F)

# the normal procedure to lump chains not applicable, since hierachical model:
# s.coda <- do.call(mcmc.list, alply(s, 2, mcmc)) # create coda object
# combinedchains <- lumpchains(s.coda) # lumpchains combines the chains in mcmc.list
```



### Rename axis-labels
```{r Parameter_names}
#dnam <- GraphInput$parameters
 # [1] "b0"                      "parEnvironment[1]"       "parEnvironment[2]"       "parEnvironment[3]"       "parEnvironment[4]"      
 #  [6] "parEnvironment[5]"       "parEnvironment[6]"       "parEnvironment[7]"       "parEnvironment[8]"       "parEnvironment[9]"      
 # [11] "parEnvironment[10]"      "parEnvironment[11]"    


# ParameterNames  <- c("b0PlantSymptoms","realVectorPredictionsMeanPlantSymptoms","realPathogen2012PredictionsPlantSymptoms","realVectorPathogenInteraction","elevation","Riesling","Rulaender","Spaetburgunder","Ut5m2008","Ut5m2009","Ut5m2011")
#   
# 
# abbr<-read.table("data/abbreviations.csv",sep="\t") # load correct notation
# nameReplace<-which(ParameterNames %in% abbr[,1])    # which need to be replaced with correct notation?
# for (i in nameReplace){ ParameterNames[i]<-as.vector(abbr[which(abbr[,1] %in% ParameterNames[i]),2])}
# 
# ParameterNames   <- ParameterNames[1:length(ParameterNamesVector)]
```


# Predictions
## Posterior predictive simulations - Simulated Response
```{r Predictions_posterior_simulatedResponse}
# # posterior is nIter (e.g. 1000) iterations by nChain (e.g. 4) chains by nPar (e.g. 20) parameters. 
# # So, grepl("^realVectorPredictions",dimnames(posterior)[[3]])] extracts the parameters whose first two letters are realVectorPredictions, 
# # leaving a nIter by nChain by nPar array. The apply() command applies the specified function to the specified dimension of the resulting array, 
# # in this case the mean function to the third dimension

# dimnames(posterior) # lists all objects
# get median of predictions,e.g.: as.vector(apply(predictedPathogen, 1, median))


modelPredictions <- NULL
modelPredictions<-apply(posterior, MARGIN=1:2, FUN = function(draw) draw[grepl("^DiseasePredictions[\\[]",names(draw))])

# combine 4 chains
simulatedPredictedWhitePlaque <- NULL
simulatedPredictedWhitePlaque <- cbind(modelPredictions[,,1], modelPredictions[,,2], modelPredictions[,,3], modelPredictions[,,4]) #  combining chains, see also: combine.mcmc from runjags package


```



## Median model predictions on the linear / response scale - Fitted predicted response
```{r Predictions_posterior_fittedPredictedResponse}
# Plant Symptoms
modelPredictions <- NULL
modelPredictions<-apply(posterior, MARGIN=1:2, FUN = function(draw) draw[grepl("^RealDisease[\\[]",names(draw))])

# combine 4 chains
predictionsLinearWhitePlaque <- NULL
predictionsLinearWhitePlaque <- cbind(modelPredictions[,,1], modelPredictions[,,2], modelPredictions[,,3], modelPredictions[,,4]) #  combining chains, see also: combine.mcmc from runjags package
predictionsResponseMedianWhitePlaque <- inv.logit(as.vector(apply(predictionsLinearWhitePlaque, 1, median)))*White1$Ntot
```


### Extraction of coefficients
```{r graph_coefficients}
# define which rows to extract from GraphInput
modelParameterLength <- length(which(grepl("b0|par",dnam))) # total number of parameters from all models
#Vector
Nrows<-c(1:length(rep(seq(1:modelParameterLength),each=4)))


# Medians
varMedianPlotWhitePlaque <- GraphInput$var.median[Nrows,]

datqPlotWhitePlaque <- GraphInput$datq
```


### 
```{r save}
save(
posterior,GraphInput,

# Observations
observedWhitePlaque,
# Predictions
# 1. Posterior predictive simulations
simulatedPredictedWhitePlaque,


# 2. Median model predictions on the linear / response scale
predictionsLinearWhitePlaque,

predictionsResponseMedianWhitePlaque,



# Parameter names
#dnam,
#ParameterNamesWhitePlaque,

# Coefficients
varMedianPlotWhitePlaque,datqPlotWhitePlaque,

file=paste("data/",NameOfModelRun,"_graphinput.RData",sep=""))
```

