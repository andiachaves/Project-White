---
  pdf_document:
  fig_caption: yes
author: "Nicolas Sander, Bernd Panassiti, Florian Hartig"
date: 'created: 12.11.2016, last modified: `r format(Sys.Date(), format="%d.%m.%Y")`'
output:
  html_document: default
pdf_document: default
title: 'Bayesian Model using RSTAN: Joint Model (Potential Presence -> Abundance ->
Observed Abundance)'
subtitle:
  header-includes: \usepackage{graphicx}
keep_tex: yes
toc: yes
toc_depth: 5
word_document: default
---
  
```{r setup, warning=FALSE, echo=FALSE}
library(knitr) # for creating html-file
opts_knit$set(root.dir='../') # definining working directory; or normalizePath('../')
opts_chunk$set(fig.align='center') # aligns all figures
#opts_chunk$set(echo=FALSE) # suppresses r-code
opts_chunk$set(message=FALSE) # suppresses library outputs
opts_chunk$set(warning=FALSE) # suppresses library warnings
#opts_chunk$set(dev='pdf')
opts_chunk$set(fig.width=8, fig.height=6, message=FALSE) #qtlcharts

```

```{r load}
rm(list=ls(all=TRUE))
source("r-code/00_settings.R")
detachAllPackages() 

load(file="data/AP_workingdata_vector.RData")
set.seed(2015)

#Sys.setenv(PATH = paste("C:/Rtools/bin", Sys.getenv("PATH"), sep=";"))
#Sys.setenv(BINPREF = "C:/Rtools/mingw_$(WIN)/bin/")
```

```{r libraries}
if(!require(rstan))
{
  install.packages("rstan", repos = mir)
  require(rstan)
}
if(!require(formatR))
{
  install.packages("formatR", repos = mir)
  require(formatR)
}
if(!require(MCMCpack))
{
  install.packages("MCMCpack", repos = mir)
  require(MCMCpack)
}
if(!require(modeest))
{
  install.packages("modeest", repos = mir)
  require(modeest)
}
if(!require(IDPmisc))
{
  install.packages("IDPmisc", repos = mir)
  require(IDPmisc)
}
if(!require(shinystan))
{
  install.packages("shinystan", repos = mir, dependencies = T)
  require(shinystan)
}
if(!require(qtlcharts))
{
  install.packages("qtlcharts", repos = mir)
  require(qtlcharts)
}
if(!require(lme4))
{
  install.packages("lme4", repos = mir)
  require(lme4)
}
if(!require(plyr))
{
  install.packages("plyr", repos = mir)
  require(plyr)
}
if(!require(dplyr))
{
  install.packages("dplyr")
  require(dplyr)
}
if(!require(boot))
{
  install.packages("boot")
  require(boot)
}
if(!require(ggmcmc))
{
  install.packages("ggmcmc")
  require(ggmcmc)
}
#suppressWarnings(dir.create(file.path(getwd(), "results/rstan")))
```

```{r Data Preperation P-generation}
#ONE LAST CORRELATION CHECK
#iplotCorr(modeldata.t[c(8:ncol(modeldata.t))], reorder=TRUE,chartOpts=list(margin = list(left=150, top=40, right=5, bottom=70, inner=5))) #all predictors, except forest groups
data_P <- c.melanoneuraPB
#data_P <- c.pictaPB

# Climate and Weather simulations: 
# - starting from 1971, max. Temp.
# - processed and simulated by Johannes Brenner and Lorenzo Sangelantoni
# - climate: from 1971 - 2016, average of annual means

################# FLIGHT MODEL #####################################

################## ENVIRONMENTAL MODEL  #############################
#changing site_id to numeric
data_P$site_id_num <- as.factor(data_P$site_id)
data_P$site_id_num <- as.numeric(data_P$site_id_num)

#Number of sites
N <- max(data_P$site_id_num)

#Region as factor
data_P$region_n <- as.numeric(as.factor(data_P$region))

################## OCCUPANCY MODEL  #################################
#Adding presence-absence data_P for each site over all years
presence_overall <- subset(data_P, select=c(site_id, amount))
presence_overall <- presence_overall %>% group_by(site_id) %>% summarise(presence_overall = sum(amount))
presence_overall$presence_overall <- as.integer(apply(presence_overall[,-1], 1, function(x) {ifelse((x>0), 1, 0)})>0) #assign presence and absences
data_P <- join_all(list(data_P, presence_overall), by=c('site_id'), type='left') #joining presence for each site to data_P

P_overallPresSite <- as.data.frame(data_P %>% dplyr::group_by(site_id) %>% dplyr::summarise(presence_overall= mean(presence_overall)))

#Number of visits per site
#J <-  table(data_P$site_id_num)
#J <- as.data_P.frame(J)
#colnames(J) <- c("site_id_num","visits_tot")
#J$site_id_num <- as.numeric(as.character(J$site_id_num))
#data_P <- join_all(list(data_P, J),by='site_id_num', type='left') #attaching total number of site visits for #each observation
#data_P$visit_no <- unlist(sapply(J$visits_tot, function(x) seq(1:x)))

#Date of observation of each visit on each site, format %m-%d
data_P$date_s <- strftime(data_P$date, format = "%j")
data_P$date_s <- as.numeric(data_P$date_s)
data_P$date_s <-scale(data_P$date_s)

#Survey year
data_P$survey_year <- ifelse(data_P$year == 2013, 1, ifelse(data_P$year == 2014, 2,ifelse(data_P$year == 2015, 3,ifelse(data_P$year == 2016, 4, NA))))

#Beaten trees; scaled, but NOT centered to keep it proportional
data_P$beatentrees <- data_P$beatentrees/100


#SCALING OF OTHER PREDICTORS
#scaling here so to not loose attributes
for(j in c(13:51)){
  data_P[,j] <- scale(data_P[,j], center=T, scale=T)
}

test <- vector()
for(j in 13:ncol(data_P)){
  test[j] <- length(which(data_P[,j]>0))
}


#Predictor Matrices
#Climate Predictors
P_ClimatePreds <- cbind(data_P[,c(
  "climate_max_rcp45"
  #"climate_max_rcp85"
)])

#Topography Predictors
P_TopographyPreds <- cbind(data_P[,c(
  "average_slope_r100",
  "average_elevation_r100",
  "average_aspect_r100",
  "distance_to_conifer")])

#Landcover Predictors
P_LandcoverPreds <- cbind(data_P[,c(
  #"Water",
  "Forest",
  "Urban",
  "Agriculture",
  "Grass")])

#Forest Predictors
P_ForestPreds <- cbind(data_P[,c(
  "auwaelder",
  "buchenwaelder",
  "eichenkiefenwaelder",
  "eichenwaelder",
  "fichtentannenbuchenwaelder",
  "fichtentannenwaelder",
  #"gnerlenlatschenbuschwaelder",
  "kiefernwaelder",
  "laubwaelder",
  #"laerchenzirbenwaelder",
  "laerchenwaelder",
  "mannaeschenhopfenbuchenwaelder",
  "montanefichtenwaelder",
  "subalpinefichtenwaelder")])

#P_TempsumPreds <- cbind(data_P[,c(
#  "tempsum")])

P_TempDRM <- cbind(data_P[,c(
  "max30DRM45"
  #"max30DRM85"
)])


P_ApplePreds <- cbind(data_P[,c(
  "golden",
  "gala",
  "fuji",
  #"granny",
  #"pinklady",
  "red",
  #"crippspink",
  "braeburn")])


#attach(data)
```

```{r Model Setup}
# data as a list
dataList = list(
  
  #counters
  P_nObs=nrow(data_P),                            # number of observations
  nSites  = length(unique(data_P$site_id_num)),   # number of unique sites
  P_Site = data_P$site_id_num,
  P_ntotalObsSite = as.integer(table(data_P$site_id_num)),# total number of visits for each site
  #nObsSite = data_P$visit_no,                    # visit number from 1:visits_tot[i]
  nYears = length(unique(data_P$survey_year)),    # number of unique survey years
  P_Year = data_P$survey_year,                    # year of each observation
  P_maxObs = max(data_P$amount),                  #maximum number of insects found in an observation
  
  #predictors
  P_BeatenTrees = data_P$beatentrees,             # number of trees beaten per site
  P_TopographyPreds = as.matrix(P_TopographyPreds),
  P_ForestPreds= as.matrix(P_ForestPreds),
  P_LandcoverPreds= as.matrix(P_LandcoverPreds),
  #P_Tempsum = P_TempsumPreds[,1],                # temperature sum for each observation
  P_ApplePreds = as.matrix(P_ApplePreds),
  P_ClimatePreds = as.matrix(P_ClimatePreds),
  #vectorSpecies = data_P$insect_id,
  #vectorStage = data_P$insect_stage_id,
  P_DateObs = data_P$date_s[,1],                  # date of observation
  P_TempDRM = as.matrix(P_TempDRM),               # deviation of mean max temperature over 4 weeks
  P_Region = data_P$region_n,
  nRegions = length(unique(data_P$region)),
  
  #responses
  P_vectorPres = data_P$presence,                 # 0/1 presence at each observation
  P_overallPresSiteObs = data_P$presence_overall, # overall presence of each site for each observation
  P_overallPresSite = P_overallPresSite$presence_overall,# overall presence for each site
  P_vectorAbun = data_P$amount                    # abundance at each observation
)

#Naming convention:  
#Parameter: [Model Parameter]_[Model]_[Generation]_[Predictor]
#Daten:[Generation]_[Predictor]   O R   [Predictor]

#Models:
#Flight Period Model
#Environmental Model
#Detection Model

model_AP <- '
data{
// C O U N T E R S ####################################################################
//counters for all generations
int<lower=1> nSites;                                 // number of sites
int<lower=1> nYears;                                 // number of years
int<lower=1> nRegions;                               // number of regions


// counters for Parental generation (P)
int<lower=0> P_nObs;                                 // number of observations
int<lower=1,upper=nSites> P_Site[P_nObs];            // site id for each observation
int<lower=0> P_maxObs;                               // max number of found insects in any observation
int<lower=1, upper=nYears> P_Year[P_nObs];           // year of each observation
int<lower=0, upper=1> P_overallPresSiteObs[P_nObs];  // overall presence of site,repeated for observations
int<lower=0, upper=1> P_overallPresSite[nSites];     // overall presence of site
int<lower=1> P_ntotalObsSite[nSites];                // total number of visits for each site
int<lower=1, upper=nRegions> P_Region[P_nObs];       // region for each observation

// counters for Filial generation (F1)


// P R E D I C T O R S ####################################################################
//predictors for Parental generation (P)
//  Environment model
matrix[P_nObs,4]  P_TopographyPreds;                 // matrix of tropography predictors
matrix[P_nObs,4]  P_LandcoverPreds;                  // matrix of landcover predictors
matrix[P_nObs,12] P_ForestPreds;                     // matrix of forest type predictors
matrix[P_nObs,5]  P_ApplePreds;                      // matrix of apple variety & age predictors
matrix[P_nObs,1]  P_ClimatePreds;                    // matrix of climate predictors
//	Flight period model
vector[P_nObs] P_DateObs;                            // date of observation
//	Detection model
vector[P_nObs]   P_BeatenTrees;                      // number of beaten trees per observation
matrix[P_nObs,1] P_TempDRM;                          // deviation of mean max temperature over 4 weeks


//predictors for Filial generation (F1)


// R E S P O N S E ####################################################################
//response for Parental generation
int<lower=0, upper=1> P_vectorPres[P_nObs];          // 0/1 presence at each observation
int<lower=0, upper=P_maxObs> P_vectorAbun[P_nObs];   // abundance at each observation


//response for Filial generation
}

parameters{
// Parameters - FLIGHT PERIOD MODEL - PARENTAL ################################################# 
//  Option1
real<lower=-10,upper=10> b0FlightPeriod_P_Onset;
real<lower=-10,upper=10> b0FlightPeriod_P_Offset;
real<lower=0,upper=5>   parFlightPeriod_P_Onset;
real<lower=0,upper=5>   parFlightPeriod_P_Offset;

real<lower=-10,upper=10> b0FlightPeriod_P_Onset_SA;
real<lower=-10,upper=10> b0FlightPeriod_P_Offset_SA;
real<lower=0,upper=5>   parFlightPeriod_P_Onset_SA;
real<lower=0,upper=5>   parFlightPeriod_P_Offset_SA;

real lambda;


// Parameters - ENVIRONMENTAL MODEL - PARENTAL #################################################
real<lower=-10,upper=10> b0Environment_P;
vector<lower=-5,upper=5>[4]  parEnvironment_P_TopographyPreds;
vector<lower=-5,upper=5>[4]  parEnvironment_P_LandcoverPreds;
vector<lower=-5,upper=5>[12] parEnvironment_P_ForestPreds;
vector<lower=-5,upper=5>[5]  parEnvironment_P_ApplePreds;
vector<lower=-5,upper=5>[1]  parEnvironment_P_ClimatePreds;

// Parameters - DETECTION MODEL - PARENTAL #################################################
real<lower=-10,upper=10>     b0Detection_P;
vector<lower=-5,upper=5>[1]  parDetection_P_TempDRM;

// Random Effects
vector[nSites] site_raw;
real<lower=0> tauSites;
vector[nYears] year_raw;
real<lower=0> tauYears;
//vector[nRegions] region_raw;
//real tauRegions;

// overdispersion
//vector[P_nObs] eps;
//real<lower=0> tauOverdispersion;
}

transformed parameters{
// Generation of derived parameters from parameters above should be defined here
// These will be saved and printed with the output

// Parental
real<lower=0,upper=1> flightPeriod_P[P_nObs];
real<lower=0,upper=1> flightPeriod_P_SA[P_nObs];
real<lower=0> lambdaEnvironment_P[P_nObs];   //old psi
real<lower=0,upper=1> pDetection_P[P_nObs];  //old p
real<lower=0> realAbundance_P[P_nObs];       //flightPeriod_P x lambdaEnvironment_P
real poisson_max;

poisson_max = pow(2.0,30.0);

for(i in 1:P_nObs){
// ############### ENVIRONMENTAL MODEL ################
lambdaEnvironment_P[i] = exp(b0Environment_P + P_TopographyPreds[i] * parEnvironment_P_TopographyPreds
+ P_LandcoverPreds[i]  * parEnvironment_P_LandcoverPreds
+ P_ForestPreds[i]     * parEnvironment_P_ForestPreds
+ P_ApplePreds[i]      * parEnvironment_P_ApplePreds
+ P_ClimatePreds[i]    * parEnvironment_P_ClimatePreds
+ site_raw[P_Site[i]] + year_raw[P_Year[i]]);
//+ eps[i]);


//############### FLIGHT PERIOD MODEL ################
// SIGMOIDAL
flightPeriod_P[i] = inv_logit(parFlightPeriod_P_Onset * (P_DateObs[i] - b0FlightPeriod_P_Onset ))
* (1-inv_logit(parFlightPeriod_P_Offset * (P_DateObs[i] - b0FlightPeriod_P_Offset)));


flightPeriod_P_SA[i] = inv_logit(parFlightPeriod_P_Onset_SA * (P_DateObs[i] - b0FlightPeriod_P_Onset_SA ))
* (1-inv_logit(parFlightPeriod_P_Offset_SA * (P_DateObs[i] - b0FlightPeriod_P_Offset_SA)));


//############### DETECTION MODEL/ZIP-TERM ################
// Explanation: DetectionRate f(15 day rolling mean)
pDetection_P[i] = inv_logit(b0Detection_P + P_TempDRM[i] * parDetection_P_TempDRM);


//############## LAMBDA X FLIGHTPERIOD X BEATENTREES ####################
realAbundance_P[i] = (lambdaEnvironment_P[i] * P_BeatenTrees[i] * flightPeriod_P[i]);
}
}

model{
// This is area for describing the model including the priors and likelihood
// This is the only place where sampling can be done within Stan
// All data and parameters used in this section must be defined above


// LIKELIHOOD - PARENTAL
//Standalone for plotting flight period
P_vectorPres ~ bernoulli(flightPeriod_P_SA);


// ######## (ENVIRONMENTAL * FLIGHT * BEATENTREES) * DETECTION MODEL 
//PER OBSERVATION
for(i in 1:P_nObs) {
if(P_overallPresSiteObs[i]==1) { 
// Explanation: lambda[1]*p[to find something])
target += (
bernoulli_log(0,pDetection_P[i])) +
poisson_log(P_vectorAbun[i],realAbundance_P[i]);
}

if(P_overallPresSiteObs[i]==0) {
// Explanation: exp(lambda[0]*p[to find something]) * exp(p[to find nothing])
target += (
log_sum_exp(bernoulli_log(1,pDetection_P[i]),bernoulli_log(0,pDetection_P[i]) + poisson_log(P_vectorAbun[i],realAbundance_P[i])));
}
}


//Fixed effects priors 
// Flight period model - Parental
//  Sigmoidal
b0FlightPeriod_P_Onset                 ~ normal(0, 5);  
b0FlightPeriod_P_Offset                ~ normal(0, 5);
parFlightPeriod_P_Onset                ~ normal(0,2);
parFlightPeriod_P_Offset               ~ normal(0,2); 

b0FlightPeriod_P_Onset_SA              ~ normal(0, 5);  
b0FlightPeriod_P_Offset_SA             ~ normal(0, 5);
parFlightPeriod_P_Onset_SA             ~ normal(0,2);
parFlightPeriod_P_Offset_SA            ~ normal(0,2);


// Environment model - Parental
b0Environment_P                        ~ normal(1, 5);  // Intercept
parEnvironment_P_TopographyPreds       ~ normal(0, 2);
parEnvironment_P_LandcoverPreds        ~ normal(0, 2);
parEnvironment_P_ForestPreds           ~ normal(0, 2);
parEnvironment_P_ApplePreds            ~ normal(0, 2);
parEnvironment_P_ClimatePreds          ~ normal(0, 2);

// Detection model - Parental
b0Detection_P                          ~ normal(1, 5);
parDetection_P_TempDRM                 ~ normal(0, 2);

//Hyperpriors
tauSites                               ~ inv_gamma(0.001, 0.001);
tauYears                               ~ inv_gamma(0.001, 0.001);
//tauRegions                             ~ inv_gamma(0.001, 0.001);
//tauOverdispersion ~ gamma(0.001,0.001);

//Random effects priors
site_raw                               ~ normal(0, tauSites);
year_raw                               ~ normal(0, tauYears);
//region_raw                             ~ normal(0, tauYears);

// overdispersion
//eps ~ normal(0 , tauOverdispersion);
}

generated quantities {
// Fitted predictions - Parental
real simPopulation_P [P_nObs]; 

for (i in 1:P_nObs){
if (realAbundance_P[i] < poisson_max)
simPopulation_P[i] = poisson_rng(realAbundance_P[i]*(1-bernoulli_rng(pDetection_P[i])));
else 
simPopulation_P[i] = normal_rng(realAbundance_P[i], sqrt(realAbundance_P[i]))*(1-bernoulli_rng(pDetection_P[i]));
}
}
'
```

```{r Run Model}
set.seed(6000)
rstan_options(auto_write = TRUE) # automatically save the compilied Stan program
options(mc.cores = parallel::detectCores()) # execute multiple Markov chains in parallel

#time <- proc.time()
stan.fit <- stan(model_code=model_AP, data=dataList, iter=50, chains=4,  refresh=1, control=list(adapt_delta=0.8,stepsize=0.001))
#(proc.time() - time)/60/60
```

```{r Shiny Stan, eval=FALSE}
launch_shinystan(stan.fit)
```

```{r Setting data for plotting !PLOTS WONT WORK WITHOUT RUNNING THIS COMMAND!}
data <- data_P
```

```{r GLM, eval=FALSE}
test <- glm(amount ~ 
              as.matrix(P_TopographyPreds)+
              I(distance_to_conifer^2) +
              as.matrix(P_LandcoverPreds) +
              as.matrix(P_ForestPreds) +
              as.matrix(P_ApplePreds) +
              as.matrix(P_ClimatePreds)
            
            , data=data_P, family="poisson")

test <- glm(amount ~ 
              distance_to_conifer + 
              I(distance_to_conifer^2)
            
            , data=data_P, family="poisson")

summary(test)
```

```{r ggmcmc, eval=FALSE}
Names.Environment <- data.frame(
  Parameter=c(
    paste("parEnvironment_P_TopographyPreds[", 1:4, "]", sep=""),
    paste("parEnvironment_P_LandcoverPreds[", 1:4, "]", sep=""),
    paste("parEnvironment_P_ForestPreds[", 1:12, "]", sep=""),
    paste("parEnvironment_P_ApplePreds[", 1:5, "]", sep=""),
    paste("parEnvironment_P_ClimatePreds[",1,"]",sep=""),
    paste("parDetection_P_TempDRM[",1,"]",sep="")),
  Label=c("Slope","Elevation","Aspect","Distance to coniferous forest",
          "Forest","Urban","Agriculture","Meadow",
          "Riparian","Beech","Oak-Pine","Oak","Spruce-Fir","Fir","Pine","Decidious","Larch","Manna ash-hop hornbeam","Mountain spruce","Subalpine spruce","Golden Delicious","Gala","Fuji","Red Delicious","Braeburn","Average of annual mean max. temperatures","Temperature deviation 29DRM"),
  Groups=c(rep("Topography*",4),rep("Landcover**",4),rep("Forest Type***",12),rep("Apple Cultivar",5),rep("",1),rep("",1))
)

s <- mcmc.list(lapply(1:ncol(stan.fit), function(x) mcmc(as.array(stan.fit)[,x,])))




#BASE PLOTS
S <- ggs(s,family="Topography|Landcover|Forest|Apple")
S <- ggs(s,family="ClimatePreds\\[1\\]")
ggs_traceplot(S)
ggs_histogram(S)
ggs_density(S)
ggs_caterpillar(S)
ggs_crosscorrelation(S)
ggs_autocorrelation(S)
ggs_pairs(S, lower = list(continuous = "density"))

#DOUBLE TRACEPLOT AND DENSITY
library(gridExtra)
library(ggthemes)
modelParameter <- c("Topography","Landcover",c("ApplePreds\\[1\\]|ApplePreds\\[2\\]|ApplePreds\\[3\\]|ApplePreds\\[4\\]"),c("ApplePreds\\[5\\]|ApplePreds\\[6\\]|ApplePreds\\[7\\]|ApplePreds\\[8\\]"),c            ("ForestPreds\\[1\\]|ForestPreds\\[2\\]|ForestPreds\\[3\\]|ForestPreds\\[4\\]"))
for(i in 1:length(modelParameter)){
  f1 <- ggs_traceplot(ggs(s, par_labels=Names.Environment,family=modelParameter[i])) + 
    theme_hc()
  f2 <- ggs_density(ggs(s, par_labels=Names.Environment, family=modelParameter[i])) + 
    theme_hc()
  grid.arrange(f1, f2, ncol=2, nrow=1)
}


#CATERPILLAR
Names.Environment$Color <- rep("none")
Names.Environment$Color[c(18,1)] <- "positive"
Names.Environment$Color[c(20,24,4,10)] <- "negative"
cols=c("red","black","blue")

S <- ggs(s,par_labels=Names.Environment,family="Topography|Landcover|Forest|Apple|ClimatePreds\\[1\\]|parDetection_P_TempDRM\\[1\\]")

ggs_caterpillar(S,line=0)+
  facet_grid(Groups~.,scales="free", space="free",switch = "both")+
  aes(col=Color) + scale_colour_manual(values=cols)+ 
  theme(axis.text=element_text(size=18))+
  theme(axis.text.x=element_text(size=18))+
  theme(axis.title.x=element_text(size=18))+
  theme(axis.title.y=element_text(size=18))+
  xlim(-3, 3)+
  theme(strip.text.y=element_text(size=12))
#+theme(legend.title=element_blank())



#EXPORT STANDARD PLOTS
S <- ggs(s,family="Topography|Landcover|Forest|Apple")
ggmcmc(S, file="model_simple-diag.pdf", param_page=4,plot=c("density", "traceplot", "caterpillar"))
```


```{r Plots, eval=FALSE}
pairs(stan.fit, pars=c("parFlightPeriod_P_Onset","parFlightPeriod_P_Offset"))

N <- 1000
x <- rpois(N, 1)
hist(data_P$amount, 
     xlim=c(0,20), ylim=c(0,1), probability=T, nclass=max(data_P$amount)-min(data_P$amount)+1, 
     col='lightblue',
     main='Poisson distribution, lambda=1')
lines(density(x,bw=1), col='red', lwd=3)



test <- rstan::extract(stan.fit)
flight <- apply(test$flightPeriod_P,2,mean)
plot(data_P$date_s * attr(data_P$date_s, 'scaled:scale') + attr(data_P$date_s, 'scaled:center'),flight,
     ylim=c(0,0.5),col="blue")
flight <- apply(test$flightPeriod_P_SA,2,mean)
points(data_P$date_s * attr(data_P$date_s, 'scaled:scale') + attr(data_P$date_s, 'scaled:center'),flight,
       col="red")


plot(stan.fit,pars=c("b0FlightPeriod_P_Onset_SA","b0FlightPeriod_P_Offset_SA","parFlightPeriod_P_Onset_SA","parFlightPeriod_P_Offset_SA"))
plot(stan.fit,pars=c("b0FlightPeriod_P_Onset","b0FlightPeriod_P_Offset","parFlightPeriod_P_Onset","parFlightPeriod_P_Offset"))

plot(stan.fit,pars=c("b0Detection_P","parDetection_P_TempDRM"))
test <- extract(stan.fit)
detec <- apply(test$pDetection_P,2,mean)
plot(data_P$date_s * attr(data_P$date_s, 'scaled:scale') + attr(data_P$date_s, 'scaled:center'),detec,
     col="red")
plot(detec)

#Predictor Matrices
#Climate Predictors
P_ClimatePreds <- cbind(data[,c(
  "climate_max_rcp45",
  "climate_max_rcp85"
)])

#Topography Predictors
P_TopographyPreds <- cbind(data[,c(
  "average_slope_r100",
  "average_elevation_r100",
  "average_aspect_r100",
  "distance_to_conifer")])

#Landcover Predictors
P_LandcoverPreds <- cbind(data[,c(
  #"Water",
  "Forest",
  "Urban",
  "Agriculture",
  "Grass")])

#Forest Predictors
P_ForestPreds <- cbind(data[,c(
  "auwaelder",
  "buchenwaelder",
  "eichenkiefenwaelder",
  "eichenwaelder",
  "fichtentannenbuchenwaelder",
  "fichtentannenwaelder",
  #"gnerlenlatschenbuschwaelder",
  "kiefernwaelder",
  "laubwaelder",
  #"laerchenzirbenwaelder",
  "laerchenwaelder",
  "mannaeschenhopfenbuchenwaelder",
  "montanefichtenwaelder",
  "subalpinefichtenwaelder")])

P_TempsumPreds <- cbind(data[,c(
  "tempsum")])

P_ApplePreds <- cbind(data[,c(
  "golden",
  "gala",
  "fuji",
  #"granny",
  #"pinklady",
  "red",
  #"crippspink",
  "braeburn",
  "age_oldest",
  "age_youngest",
  "age_range"
)])


# pars for print and plot
modelParameter <- c(
  
  # flight period
  "b0FlightPeriod_P_Onset",
  "b0FlightPeriod_P_Offset",
  "parFlightPeriod_P_Onset",
  "parFlightPeriod_P_Offset", 
  
  "b0FlightPeriod_P_Onset_SA",
  "b0FlightPeriod_P_Offset_SA",
  "parFlightPeriod_P_Onset_SA",
  "parFlightPeriod_P_Offset_SA", 
  
  # population model
  "parEnvironment_P_LandcoverPreds",
  "parEnvironment_P_TopographyPreds",
  "parEnvironment_P_ForestPreds",
  "parEnvironment_P_ApplePreds",
  "parEnvironment_P_LandcoverPreds",
  "parEnvironment_P_ClimatePreds",
  
  # detection model
  "parDetection_P_TempDRM"
)


print(stan.fit, pars=modelParameter)
plot(stan.fit, pars=modelParameter)







plot(stan.fit, plotfun = "hist", pars = "f0")
plot(stan.fit, plotfun = "hist", pars = "p")

#traceplot
plot(stan.fit, plotfun = "trace", pars = c("a0"), inc_warmup = TRUE)

posterior <- extract(stan.fit, inc_warmup=F) #extract all posterior w/o warmup
mindetectablePresence <- apply(posterior$p,2,min)
meandetectablePresence <- apply(posterior$p,2,mean)
maxdetectablePresence <- apply(posterior$p,2,max)

plot(stan.fit)
hist(meandetectablePresence)

results <- data.frame(cbind(data$date,
                            (mindetectablePresence),
                            (meandetectablePresence),
                            (maxdetectablePresence)
))
names(results) <- c("date","minPP","meanPP","maxPP")

#results <- as.data.frame(results %>% dplyr::group_by(date) %>% dplyr::summarise(minPP = min(minPP), meanPP=mean(meanPP), maxPP=max(maxPP)))

results <- results[order(results$date), ] #reorder based on date


Sys.setlocale("LC_TIME", "English") # to match English date structure
par(oma=c(2,1,0,0))
plot(as.POSIXct(results$date,origin="1970-01-01"),results$meanPP,pch=16,col = adjustcolor("red",0),
     main="c.melanoneuraF1B", xlab="", ylab="Detectable Presence",ylim=c(0,1),xaxt="n")

#plot posterior min and max polygon
#points(results$date,results$minPP,col="orange")
#points(results$date,results$maxPP,col="orange")

#plot posterior mean
points(results$date,results$meanPP,col=adjustcolor("black",0.75),lwd=1)  
#plot posterior min and max polygon
points(results$date,results$minPP,col=adjustcolor("black",0))
points(results$date,results$maxPP,col=adjustcolor("black",0))
polygon(c(results$date,rev(results$date)),c(results$maxPP,rev(results$minPP)),col = adjustcolor("green",0.3),border=NA)

#simple GLM comparison
glmpresence <- glm(data$amount ~ 
                     average_slope_r100 +
                     average_elevation_r100 + 
                     average_aspect_r100 +
                     distance_to_conifer +
                     Forest +
                     Urban +
                     Agriculture +
                     Grass +
                     auwaelder +
                     eichenwaelder +
                     fichtentannenbuchenwaelder +
                     fichtentannenwaelder +
                     kiefernwaelder +
                     laerchenzirbenwaelder +
                     laerchenwaelder +
                     montanefichtenwaelder +
                     subalpinefichtenwaelder
                   ,data=data, family="poisson")
###predictions

#add real data
points(data$date,data$presence,pch=16,col = adjustcolor(ifelse(data$presence > 0,'blue','red'),0.1))

#x-axis
minor <- seq(as.POSIXct("2013-01-01", format = "%Y-%m-%d"), max(data$date),
             by = "1 months")
labDates <- seq(as.POSIXct("2013-01-01", format = "%Y-%m-%d"),max(data$date), by = "2 months")
axis.POSIXct(side = 1, data$date, at = labDates, format = "%b", las = 2)
axis.POSIXct(side = 1, data$date, at = minor, labels = FALSE, tcl = -0.25)
axis.POSIXct(side = 1, data$date, format = "%Y",las=2, line=2,lty=0)

###legend###
#par(fig = c(0, 1, 0, 1), oma = c(0, 0, 0, 0), mar = c(0, 0, 0, 0), new = TRUE)
#plot(0, 0, type = "n", bty = "n", xaxt = "n", yaxt = "n")
legend(as.POSIXct("2014-05-01"),1, c("Mean Detectable Presence","Min:Max Detectable Presence","0 insects","# of insects found"), col=c("black",adjustcolor("green",0.3),"red","blue"),pch=c(NA,15,16,16),lty=c(1,NA,NA,NA),bty="n",cex=0.75,horiz = F)


#############################################################
plot(density(inv.logit(posterior$p)),
     xlab="Presence", col=grey(0, 0.8),
     main="Predicitive distribution")
lines(density((posterior$simulatedVector)),
      xlab="Presence", col=grey(0, 0.8),
      main="Predicitive distribution")

#Predicted Insects
#plot(data$tempsum * attr(data$tempsum, 'scaled:scale') + attr(data$tempsum, #'scaled:center'),posterior$vectorPreds[1,],pch=16,col = adjustcolor(ifelse(posterior$vectorPreds[1,] > #0,'blue','red'),0.1),
#     main="Predicted Vector", xlab="Temperature Sum °C", ylab="Predicted Vector")


#test <- dplyr::bind_cols(preds)
test <- do.call(cbind, preds)
ggplot(preds, aes("new.trDAY", "50%")) + 
  geom_line(aes(colour = names(preds)) )  + 
  geom_point( aes(shape = names(preds)))
```

###### FLIGHT PERIOD MODEL - FINAL PLOT #########
```{r flight plot 1st option DATE, eval=FALSE}
#1st Option
###################################### 2n Option (old occupancy model)#################
### predictions using the rstan model, based on "Bayesian data analysis in ecology using linear models" by Fraenzi Korner-Nievergelt
Sys.setlocale("LC_TIME", "English") # to match English date structure
#par(oma=c(2,2,2,2))
#par(mfrow=c(1,1))
colette <- c("orange","green","darkblue","red")
y<-"2016"
par(oma=c(0,0,2,0))

#for(r in sort(unique(data_P$region))){
plot(data$date, data$presence ,col=adjustcolor("red",0), ylim=c(0,1), ylab="p", xlab="", xaxt="n",xlim=c(as.POSIXct(paste(2016,"-01-01",sep=""),format="%Y-%m-%d"),as.POSIXct(paste(2016,"-07-01",sep=""),format="%Y-%m-%d")),main="Presence Probability \nwith 95% Credibility Interval",las=1) 


#for(y in sort(unique(data_P$year))){
#predictions
#new.DAY <- seq(min(tmp$date_s),max(tmp$date_s),0.001) #actual survey period
#new.trDAY <- new.DAY
#new.DAY <- seq(min(tmp$date),max(tmp$date),"1 day") #actual survey period
#new.DAY <- seq(0,180,1)
#new.DAY <- as.numeric(strftime(new.DAY, format = "%j"))
#new.trDAY <- scale(new.DAY)
#new.DAY <- seq(min(data$date_s),max(data$date_s),0.001) #actual survey period
#new.trDAY <- new.DAY
new.DAY <- seq(0,240,1)
new.trDAY <- (new.DAY  - attr(data$date_s, 'scaled:center'))/ attr(data$date_s, 'scaled:scale')
modsims <- rstan::extract(stan.fit)
nsim <- dim(modsims$b0FlightPeriod_P_Onset_SA)[1]
fitp <- array(dim=c(nsim, length(new.trDAY)))
#colnames(modsims$year_raw) <- c("2013","2014","2015","2016") #renaming the random effect years
#colnames(modsims$region_raw) <- sort(unique(data_P$region)) #renaming the random effect years
for(i in 1:nsim){
  #QUADRATIC
  '  fitp[i,] <- plogis(modsims$b0FlightPeriod_P_SA[i] 
  + modsims$parFlightPeriod_P_DateObs_SA[i]*new.trDAY
  + modsims$parFlightPeriod_P_DateObs2_SA[i]*new.trDAY^2)'
  #+ modsims$year_raw[i,y] + modsims$region_raw[i,r])
  #SIGMOIDAL
  '       fitp[i,] <- plogis(modsims$parFlightPeriod_P_Onset[i]*(new.trDAY-modsims$b0FlightPeriod_P_Onset[i]))*
  (1-plogis(modsims$parFlightPeriod_P_Offset[i]*(new.trDAY-modsims$b0FlightPeriod_P_Offset[i])))'
  fitp[i,] <- plogis(modsims$parFlightPeriod_P_Onset_SA[i]*(new.trDAY-modsims$b0FlightPeriod_P_Onset_SA[i]))*
    (1-plogis(modsims$parFlightPeriod_P_Offset_SA[i]*(new.trDAY-modsims$b0FlightPeriod_P_Offset_SA[i])))
  '  fitp[i,] <- plogis(modsims$b0FlightPeriod_P_Onset[i] + new.trDAY * modsims$parFlightPeriod_P_Onset[i] + new.trDAY * new.trDAY * modsims$parFlightPeriod_P_Onset2[i])'
}
preds <- apply(fitp,2,quantile,probs=c(0.025,0.5,0.975))

#PLOTS
lines(strptime(paste(2016, new.trDAY * attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center')), format="%Y %j"), preds[2,], col = adjustcolor(colette[which(sort(unique(data$year))==y)],1),type="l",lty=1,lwd=2)
lines(strptime(paste(2016, new.trDAY * attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center')), format="%Y %j"),preds[1,],col = adjustcolor(colette[which(sort(unique(data$year))==y)],0),lwd=0.5,lty=2)
lines(strptime(paste(2016, new.trDAY * attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center')), format="%Y %j"),preds[3,],col = adjustcolor(colette[which(sort(unique(data$year))==y)],0),lwd=0.5,lty=2)  

polygon(c(strptime(paste(2016, new.trDAY * attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center')), format="%Y %j"),rev(strptime(paste(2016, new.trDAY * attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center')), format="%Y %j"))),c(preds[3,],rev(preds[1,])),col = adjustcolor(colette[which(sort(unique(data$year))==y)],0.1),border=NA)

#points(strptime(paste(2016, tmp$date_s * attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center')), format="%Y %j"),tmp$presence,pch=16,col = adjustcolor(ifelse(tmp$presence > 0,'blue','red'),0.1))

#x-axis
minor <- seq(as.POSIXct(paste(y,"-01-01",sep=""), format = "%Y-%m-%d"),as.POSIXct(paste(y,"-07-01",sep=""), format = "%Y-%m-%d"),by = "1 months")
labDates <- seq(as.POSIXct(paste(y,"-01-01",sep=""), format = "%Y-%m-%d"),as.POSIXct(paste(y,"-07-01",sep=""), format = "%Y-%m-%d"),by = "1 months")
axis.POSIXct(side = 1, tmp$date, at = labDates+60*60*24*14, format = "%b", las = 1,tcl=0)
axis.POSIXct(side = 1, tmp$date, at = minor, labels = FALSE, tcl = -0.25)
#axis.POSIXct(side = 1, tmp$date, format = "%Y",las=2, line=2,lty=0)
mtext("Date",side=1,line=3,cex=1)
#}
#title("p Predictions",outer=T,cex.main=1)
#legend("topright", c("2013","2014","2015","2016"), col=colette,lty=c(1,1,1,1),bty="n",cex=1)
#title(paste(r),outer=T,cex.main=1)
#}


###########
posterior <- rstan::extract(stan.fit, inc_warmup=F) #extract all posterior w/o warmup
minpotentialPresence <- apply(posterior$flightPeriod_P,2,min)
meanpotentialPresence <- apply(posterior$flightPeriod_P,2,mean)
maxpotentialPresence <- apply(posterior$flightPeriod_P,2,max)
meanflight <- apply(posterior$simFlightPeriod_P,2,mean)

results <- data.frame(cbind(data$date_s,
                            minpotentialPresence,
                            meanpotentialPresence,
                            maxpotentialPresence,
                            meanflight
))
names(results) <- c("date_s","minPP","meanPP","maxPP","flight")

results <- results[order(results$date_s), ] #reorder based on date_s

plot(data$date_s* attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center'),results$meanPP,pch=16,col = adjustcolor("red",0),
     main="c.melF1", xlab="Day of Year", ylab="Potential Presence",ylim=c(0,1),xlim=c(0,150))

#plot posterior min and max polygon
lines(results$date_s* attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center'),results$minPP,col="orange")
lines(results$date_s* attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center'),results$maxPP,col="orange")
polygon(c(results$date_s* attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center'),rev(results$date_s* attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center'))),c(results$maxPP,rev(results$minPP)),col = adjustcolor("green",0.3),border="white")

#plot posterior mean
lines(results$date_s* attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center'),results$meanPP,type="l",col="black",lwd=2)  
#lines(results$date_s,results$flight,type="l",col="black",pch=1)  


#simple GLM comparison
glmpresence <- glm(presence ~ date_s + I(date_s^2), data=data, family="binomial")
###predictions
rangex <- range(data$date_s, na.rm=T)
#testx <- as.matrix(seq(min(rangex), max(rangex), 0.01))
testx <- as.matrix(seq(-40000,100000,0.1))
testy <- predict(glmpresence, list(date_s = testx),type="response")
lines(testx * attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center'),testy,col="red",lty=2,lwd=2)

#add real data
points(data$date_s* attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center'),data$presence,pch=16,col = adjustcolor(ifelse(data$presence > 0,'blue','red'),0.1))

#legend
legend("right", c("Presence","Absence","GLM","Mean Potential Presence","Min:Max Potential Presence"), col=c("blue","red","red","black",adjustcolor("green",0.3)),lty=c(NA,NA,2,1,NA),pch=c(16,16,NA,NA,15),bty="n")

######### Quick checks
#meanPP <- apply(posterior$flightPeriod_P,2,mean)
#plot(data$date,meanPP)

#meanPPTest <- apply(posterior$flightPeriod_P_Standalone,2,mean)
#plot(data$date,meanPPTest)

plot(posterior$flightPeriod_P,posterior$flightPeriod_P_Standalone)
```

######  BEATEN TREES #############
```{r beaten trees plot, eval=FALSE}
#2nd Option
###################################### 2n Option #################
### predictions using the rstan model, based on "Bayesian data analysis in ecology using linear models" by Fraenzi Korner-Nievergelt
Sys.setlocale("LC_TIME", "English") # to match English date structure
#par(oma=c(2,2,2,2))
#par(mfrow=c(1,1))
colette <- c("orange","green","darkblue","red")

plot(data$beatentrees * attr(data$beatentrees, 'scaled:scale') + attr(data$beatentrees, 'scaled:center'), data$presence ,col=adjustcolor("red",0), ylim=c(0,100),xlim=c(0,250), ylab="Detection Probability", xlab="Number of Beaten Trees",main="Detection Probability \nwith 95% Credibility Intervals",las=1) 
#predictions
new.BT <- seq(1,250,1)
new.trBT <- (new.BT  - attr(data$beatentrees, 'scaled:center'))/ attr(data$beatentrees, 'scaled:scale')
#new.trBT <- (new.BT  - attr(data$beatentrees, 'scaled:center'))/ attr(data$beatentrees, 'scaled:scale')
modsims <- extract(stan.fit)
nsim <- dim(modsims$b0Detection_P)[1]
fitp <- array(dim=c(nsim, length(new.trBT)))
#colnames(modsims$b0) <- c("2013","2014","2015","2016") #renaming the random effect years
#colnames(modsims$b1) <- c("2013","2014","2015","2016") #renaming the random effect years
#colnames(modsims$b2) <- c("2013","2014","2015","2016") #renaming the random effect years
#colnames(modsims$year) <- c("2013","2014","2015","2016") #renaming the random effect years
for(i in 1:nsim){
  fitp[i,] <- exp(modsims$b0BeatenTrees_P_SA[i] 
                  + modsims$parBeatenTrees_P_BeatenTrees_SA[i]*new.trBT)
}
preds <- apply(fitp,2,quantile,probs=c(0.025,0.5,0.975))

#PLOTS
lines(new.trBT * attr(data$beatentrees, 'scaled:scale') + attr(data$beatentrees, 'scaled:center'), preds[2,], col = adjustcolor("red",1),type="l",lty=1,lwd=2)
lines(new.trBT * attr(data$beatentrees, 'scaled:scale') + attr(data$beatentrees, 'scaled:center'),preds[1,],col = adjustcolor("red",0),lwd=0.5,lty=2)
lines(new.trBT * attr(data$beatentrees, 'scaled:scale') + attr(data$beatentrees, 'scaled:center'),preds[3,],col = adjustcolor("red",0),lwd=0.5,lty=2)  
polygon(c(new.trBT* attr(data$beatentrees, 'scaled:scale') + attr(data$beatentrees, 'scaled:center'),rev(new.trBT* attr(data$beatentrees, 'scaled:scale') + attr(data$beatentrees, 'scaled:center'))),c(preds[3,],rev(preds[1,])),col = adjustcolor("red",0.1),border=NA)

#points(strptime(paste(2016, tmp$date_s * attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center')), format="%Y %j"),tmp$presence,pch=16,col = adjustcolor(ifelse(tmp$presence > 

title("p Predictions",outer=T,cex.main=1)
#legend("topright", c("2013","2014","2015","2016"), col=colette,lty=c(1,1,1,1),bty="n",cex=1)

###########
posterior <- extract(stan.fit, inc_warmup=F) #extract all posterior w/o warmup
minDetection <- apply(posterior$beatenTrees_P_Standalone,2,min)
meanDetection <- apply(posterior$beatenTrees_P_Standalone,2,mean)
maxDetection <- apply(posterior$beatenTrees_P_Standalone,2,max)
meansim <- apply(posterior$simBeatenTrees_P,2,mean)

results <- data.frame(cbind(data$beatentrees,
                            minDetection,
                            meanDetection,
                            maxDetection,
                            meansim
))
names(results) <- c("beatentrees","minD","meanD","maxD","simD")

results <- results[order(results$beatentrees), ] #reorder based on date_s

plot(data$beatentrees* attr(data$beatentrees, 'scaled:scale') + attr(data$beatentrees, 'scaled:center'),results$meanD,pch=16,col = adjustcolor("red",0),
     main="c.melP", xlab="Number of beaten trees", ylab="Detection Probability",ylim=c(0,100),xlim=c(0,250))

#plot posterior min and max polygon
lines(results$beatentrees* attr(data$beatentrees, 'scaled:scale') + attr(data$beatentrees, 'scaled:center'),results$minD,col="orange")
lines(results$beatentrees* attr(data$beatentrees, 'scaled:scale') + attr(data$beatentrees, 'scaled:center'),results$maxD,col="orange")
polygon(c(results$beatentrees* attr(data$beatentrees, 'scaled:scale') + attr(data$beatentrees, 'scaled:center'),rev(results$beatentrees* attr(data$beatentrees, 'scaled:scale') + attr(data$beatentrees, 'scaled:center'))),c(results$maxD,rev(results$minD)),col = adjustcolor("green",0.3),border="white")

#plot posterior mean
lines(results$beatentrees* attr(data$beatentrees, 'scaled:scale') + attr(data$beatentrees, 'scaled:center'),results$meanD,type="l",col="black",lwd=2)  
#lines(results$beatentrees,results$simD,type="l",col="black",pch=1)  


#simple GLM comparison
#glmdetection <- glm(presence ~ beatentrees + I(beatentrees^2), data=data, family="binomial")
glmdetection <- glm(amount ~ beatentrees, data=data, family="poisson")
###predictions
rangex <- range(data$beatentrees, na.rm=T)
#testx <- as.matrix(seq(min(rangex), max(rangex), 0.01))
testx <- as.matrix(seq(-3,3,0.1))
testy <- predict(glmdetection, list(beatentrees = testx),type="response")
lines(testx * attr(data$beatentrees, 'scaled:scale') + attr(data$beatentrees, 'scaled:center'),testy,col="red",lty=2,lwd=2)

#add real data
points(data$beatentrees * attr(data$beatentrees, 'scaled:scale') + attr(data$beatentrees, 'scaled:center'),data$presence,pch=16,col = adjustcolor(ifelse(data$presence > 0,'blue','red'),0.1))

#legend
legend("right", c("Presence","Absence","GLM","Mean Detection Probability","Min:Max Detection Probability"), col=c("blue","red","red","black",adjustcolor("green",0.3)),lty=c(NA,NA,2,1,NA),pch=c(16,16,NA,NA,15),bty="n")

```

###### POPULATION MODEL - FINAL PLOT #########
```{r environmental plot !INCOMPLETE!, eval=FALSE}
### predictions using the rstan model, based on "Bayesian data analysis in ecology using linear models" by Fraenzi Korner-Nievergelt
Sys.setlocale("LC_TIME", "English") # to match English date structure
#par(oma=c(2,2,2,2))
#par(mfrow=c(1,1))
colette <- c("orange","green","darkblue","red")

plot(data$date, data$presence ,col=adjustcolor("red",0), ylim=c(0,1), ylab="p", xlab="", xaxt="n",xlim=c(as.POSIXct(paste(2016,"-01-01",sep=""),format="%Y-%m-%d"),as.POSIXct(paste(2016,"-07-01",sep=""),format="%Y-%m-%d")),main="Detection Probability \nwith 95% Credibility Intervals") 
for(y in sort(unique(data$year))){
  
  #predictions
  tmp <- subset(data, data$year == y)
  #new.DAY <- seq(min(tmp$date_s),max(tmp$date_s),0.001) #actual survey period
  #new.trDAY <- new.DAY
  #new.DAY <- seq(min(tmp$date),max(tmp$date),"1 day") #actual survey period
  #new.DAY <- seq(0,180,1)
  #new.DAY <- as.numeric(strftime(new.DAY, format = "%j"))
  #new.trDAY <- scale(new.DAY)
  #new.DAY <- seq(min(data$date_s),max(data$date_s),0.001) #actual survey period
  #new.trDAY <- new.DAY
  new.DAY <- seq(0,240,1)
  new.trDAY <- (new.DAY  - attr(data$date_s, 'scaled:center'))/ attr(data$date_s, 'scaled:scale')
  modsims <- extract(stan.fit)
  nsim <- dim(modsims$b0)[1]
  fitp <- array(dim=c(nsim, length(new.trDAY)))
  #colnames(modsims$b0) <- c("2013","2014","2015","2016") #renaming the random effect years
  #colnames(modsims$b1) <- c("2013","2014","2015","2016") #renaming the random effect years
  #colnames(modsims$b2) <- c("2013","2014","2015","2016") #renaming the random effect years
  colnames(modsims$year) <- c("2013","2014","2015","2016") #renaming the random effect years
  for(i in 1:nsim){
    fitp[i,] <- plogis(modsims$b0[i] + modsims$b1[i]*new.trDAY +
                         modsims$b2[i]*new.trDAY^2 + modsims$year[i,y])
  }
  preds <- apply(fitp,2,quantile,probs=c(0.025,0.5,0.975))
  
  #PLOTS
  lines(strptime(paste(2016, new.trDAY * attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center')), format="%Y %j"), preds[2,], col = adjustcolor(colette[which(sort(unique(data$year))==y)],1),type="l",lty=1,lwd=2)
  lines(strptime(paste(2016, new.trDAY * attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center')), format="%Y %j"),preds[1,],col = adjustcolor(colette[which(sort(unique(data$year))==y)],0),lwd=0.5,lty=2)
  lines(strptime(paste(2016, new.trDAY * attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center')), format="%Y %j"),preds[3,],col = adjustcolor(colette[which(sort(unique(data$year))==y)],0),lwd=0.5,lty=2)  
  
  polygon(c(strptime(paste(2016, new.trDAY * attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center')), format="%Y %j"),rev(strptime(paste(2016, new.trDAY * attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center')), format="%Y %j"))),c(preds[3,],rev(preds[1,])),col = adjustcolor(colette[which(sort(unique(data$year))==y)],0.1),border=NA)
  
  #points(strptime(paste(2016, tmp$date_s * attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center')), format="%Y %j"),tmp$presence,pch=16,col = adjustcolor(ifelse(tmp$presence > 0,'blue','red'),0.1))
  
  #x-axis
  minor <- seq(as.POSIXct(paste(y,"-01-01",sep=""), format = "%Y-%m-%d"),as.POSIXct(paste(y,"-07-01",sep=""), format = "%Y-%m-%d"),by = "1 months")
  labDates <- seq(as.POSIXct(paste(y,"-01-01",sep=""), format = "%Y-%m-%d"),as.POSIXct(paste(y,"-07-01",sep=""), format = "%Y-%m-%d"),by = "1 months")
  axis.POSIXct(side = 1, tmp$date, at = labDates, format = "%b", las = 2)
  axis.POSIXct(side = 1, tmp$date, at = minor, labels = FALSE, tcl = -0.25)
  #axis.POSIXct(side = 1, tmp$date, format = "%Y",las=2, line=2,lty=0)
  mtext("Date",side=1,line=3,cex=1)
}
title("p Predictions",outer=T,cex.main=1)
legend("topright", c("2013","2014","2015","2016"), col=colette,lty=c(1,1,1,1),bty="n",cex=1)

####################################################

plot(stan.fit, plotfun="hist",pars="psi_sim")

posterior <- extract(stan.fit, inc_warmup=F) #extract all posterior w/o warmup
minpsi <- apply(posterior$psi,2,min)
meanpsi <- apply(posterior$psi,2,mean)
maxpsi <- apply(posterior$psi,2,max)
meanpsi_sim <- apply(posterior$psi_sim,2,mean)

results <- data.frame(cbind(forestPreds,
                            minpsi,
                            meanpsi,
                            maxpsi,
                            meanpsi_sim
))



#real presence vs predictor
for(i in 1:length(forestPreds)){
  results <- data.frame(cbind(forestPreds[i],
                              minpsi,
                              meanpsi,
                              maxpsi,
                              meanpsi_sim
  ))
  results <- results[order(results[,1]), ] #reorder based on forestPred
  plot(results[1][,1]* attr(forestPreds[,i], 'scaled:scale') + attr(forestPreds[,i], 'scaled:center') , results$meanpsi,type="l",
       main=paste(names(forestPreds[i])),xlab=parse(text=paste("m","^2", sep="")), ylab="Presence Probability [psi]")
  points(results[1][,1]* attr(forestPreds[,i], 'scaled:scale') + attr(forestPreds[,i], 'scaled:center'),results$minpsi,col=adjustcolor("orange",0))
  points(results[1][,1]* attr(forestPreds[,i], 'scaled:scale') + attr(forestPreds[,i], 'scaled:center'),results$maxpsi,col=adjustcolor("orange",0))
  polygon(c(results[1][,1]* attr(forestPreds[,i], 'scaled:scale') + attr(forestPreds[,i], 'scaled:center'),rev(results[1][,1]* attr(forestPreds[,i], 'scaled:scale') + attr(forestPreds[,i], 'scaled:center'))),c(results$maxpsi,rev(results$minpsi)),col = adjustcolor("green",0.3),border="white")
  
  points(results[1][,1]* attr(forestPreds[,i], 'scaled:scale') + attr(forestPreds[,i], 'scaled:center') , results$meanpsi_sim, col=adjustcolor("red",0.1))
}

#parameter value for each iteration
for(i in 1:length(forestPreds)){
  hist(posterior$parforestPreds[,i] * attr(data$auwaelder, 'scaled:scale') + attr(data$auwaelder, 'scaled:center')
       ,main=paste("Histogram of Parameter: ",names(forestPreds[i]))
       ,xlab="Parameter Value")
  abline(h=mean(posterior$parforestPreds[,i]))
  
  hist(posterior$parforestPreds[,i],main=paste("Histogram of Parameter: ",names(forestPreds[i]))
       ,xlab="Parameter Value")
}


plot(results$tempsum,results$meanPP,pch=16,col = adjustcolor("red",0),
     main="c.melF1", xlab="Temperature Sum °C", ylab="Potential Presence",ylim=c(0,1),xlim=c(-4000,100000))

#plot posterior min and max polygon
lines(results$tempsum,results$minPP,col="orange")
lines(results$tempsum,results$maxPP,col="orange")
polygon(c(results$tempsum,rev(results$tempsum)),c(results$maxPP,rev(results$minPP)),col = adjustcolor("green",0.3),border="white")

#plot posterior mean
lines(results$tempsum,results$meanPP,type="l",col="black",lwd=2)  
#lines(results$tempsum,results$flight,type="l",col="black",pch=1)  


#simple GLM comparison
glmpresence <- glm(presence ~ tempsum + I(tempsum^2), data=data, family="binomial")
###predictions
rangex <- range(data$tempsum, na.rm=T)
#testx <- as.matrix(seq(min(rangex), max(rangex), 0.01))
testx <- as.matrix(seq(-40000,100000,0.1))
testy <- predict(glmpresence, list(tempsum = testx),type="response")
lines(testx * attr(data$tempsum, 'scaled:scale') + attr(data$tempsum, 'scaled:center'),testy,col="red",lty=2,lwd=2)

#add real data
points(data$tempsum* attr(data$tempsum, 'scaled:scale') + attr(data$tempsum, 'scaled:center'),data$presence,pch=16,col = adjustcolor(ifelse(data$presence > 0,'blue','red'),0.1))

#legend
legend("right", c("Presence","Absence","GLM","Mean Potential Presence","Min:Max Potential Presence"), col=c("blue","red","red","black",adjustcolor("green",0.3)),lty=c(NA,NA,2,1,NA),pch=c(16,16,NA,NA,15),bty="n")

############################################
#Plot for distance to coniferous forest vs. predictions (from generated quantities)
posterior <- extract(stan.fit)
meanpsi_sim <- apply(posterior$psi_sim,2,mean)
meanpardistance <- mean(posterior$partopographyPreds[,4])
results <- data.frame(data$distance,meanpsi_sim)
results <- results[order(results$data.distance), ] #reorder based on distance

plot(results$data.distance * attr(data$distance, 'scaled:scale') + attr(data$distance, 'scaled:center'),
     results$meanpsi_sim,
     xlab="Distance to nearest coniferous forest [m]",
     ylab="Predicted presence probability",
     col=adjustcolor("black",0.5),
     ylim=c(0,1),
     main="C.SPECIES F1")
lines(results$data.distance * attr(data$distance, 'scaled:scale') + attr(data$distance, 'scaled:center'),inv.logit(meanpardistance*results$data.distance),col="red")
legend("topright",c("Distance parameter"),col=c("red"),lty=1,bty="n")
```

###### DETECTION MODEL - FINAL PLOT #########
```{r detec plot 1st option TempDRM, eval=FALSE}
#1st Option
###################################### 1st Option #################
### predictions using the rstan model, based on "Bayesian data analysis in ecology using linear models" by Fraenzi Korner-Nievergelt
Sys.setlocale("LC_TIME", "English") # to match English date structure
#par(oma=c(2,2,2,2))
#par(mfrow=c(1,1))
colette <- c("orange","green","darkblue","red")

plot(data$tempdaymean * attr(data$tempdaymean, 'scaled:scale') + attr(data$tempdaymean, 'scaled:center'), data$presence ,col=adjustcolor("red",0), ylim=c(0,1),xlim=c(-6,26), ylab="Detection Probability", xlab="Mean Daily Temperature [°C]",main="Detection Probability \nwith 95% Credibility Intervals",las=1) 
#predictions
new.T <- seq(-5,25,1)
new.trT <- (new.T  - attr(data$tempdaymean, 'scaled:center'))/ attr(data$tempdaymean, 'scaled:scale')
#new.trBT <- (new.BT  - attr(data$beatentrees, 'scaled:center'))/ attr(data$beatentrees, 'scaled:scale')
modsims <- extract(stan.fit)
nsim <- dim(modsims$b0Detection_P)[1]
fitp <- array(dim=c(nsim, length(new.trT)))
#colnames(modsims$b0) <- c("2013","2014","2015","2016") #renaming the random effect years
#colnames(modsims$b1) <- c("2013","2014","2015","2016") #renaming the random effect years
#colnames(modsims$b2) <- c("2013","2014","2015","2016") #renaming the random effect years
#colnames(modsims$year) <- c("2013","2014","2015","2016") #renaming the random effect years
for(i in 1:nsim){
  fitp[i,] <- plogis(modsims$b0Detection_P[i] 
                     + modsims$parDetection_P_TempDRM[i]*new.trT)
}
preds <- apply(fitp,2,quantile,probs=c(0.025,0.5,0.975))

#PLOTS
lines(new.trT * attr(data$tempdaymean, 'scaled:scale') + attr(data$tempdaymean, 'scaled:center'), preds[2,], col = adjustcolor("red",1),type="l",lty=1,lwd=2)
lines(new.trT * attr(data$tempdaymean, 'scaled:scale') + attr(data$tempdaymean, 'scaled:center'),preds[1,],col = adjustcolor("red",0),lwd=0.5,lty=2)
lines(new.trT * attr(data$tempdaymean, 'scaled:scale') + attr(data$tempdaymean, 'scaled:center'),preds[3,],col = adjustcolor("red",0),lwd=0.5,lty=2)  
polygon(c(new.trT* attr(data$tempdaymean, 'scaled:scale') + attr(data$tempdaymean, 'scaled:center'),rev(new.trT* attr(data$tempdaymean, 'scaled:scale') + attr(data$tempdaymean, 'scaled:center'))),c(preds[3,],rev(preds[1,])),col = adjustcolor("red",0.1),border=NA)

#points(strptime(paste(2016, tmp$date_s * attr(data$date_s, 'scaled:scale') + attr(data$date_s, 'scaled:center')), format="%Y %j"),tmp$presence,pch=16,col = adjustcolor(ifelse(tmp$presence > 

title("p Predictions",outer=T,cex.main=1)
#legend("topright", c("2013","2014","2015","2016"), col=colette,lty=c(1,1,1,1),bty="n",cex=1)

###########
posterior <- extract(stan.fit, inc_warmup=F) #extract all posterior w/o warmup
minDetection <- apply(posterior$pDetection_P,2,min)
meanDetection <- apply(posterior$pDetection_P,2,mean)
maxDetection <- apply(posterior$pDetection_P,2,max)
meansim <- apply(posterior$simDetection_P,2,mean)

results <- data.frame(cbind(data$tempdaymean,
                            minDetection,
                            meanDetection,
                            maxDetection,
                            meansim
))
names(results) <- c("temp","minD","meanD","maxD","simD")

results <- results[order(results$temp), ] #reorder based on date_s

plot(data$tempdaymean* attr(data$tempdaymean, 'scaled:scale') + attr(data$tempdaymean, 'scaled:center'),results$meanD,pch=16,col = adjustcolor("red",0),
     main="c.melP", xlab="Mean Daily Temperature [°C]", ylab="Detection Probability",ylim=c(0,1),xlim=c(-5,30))

#plot posterior min and max polygon
lines(results$temp* attr(data$tempdaymean, 'scaled:scale') + attr(data$tempdaymean, 'scaled:center'),results$minD,col="orange")
lines(results$temp* attr(data$tempdaymean, 'scaled:scale') + attr(data$tempdaymean, 'scaled:center'),results$maxD,col="orange")
polygon(c(results$temp* attr(data$tempdaymean, 'scaled:scale') + attr(data$tempdaymean, 'scaled:center'),rev(results$temp* attr(data$tempdaymean, 'scaled:scale') + attr(data$tempdaymean, 'scaled:center'))),c(results$maxD,rev(results$minD)),col = adjustcolor("green",0.3),border="white")

#plot posterior mean
lines(results$temp* attr(data$tempdaymean, 'scaled:scale') + attr(data$tempdaymean, 'scaled:center'),results$meanD,type="l",col="black",lwd=2)  
#lines(results$temp,results$simD,type="l",col="black",pch=1)  


#simple GLM comparison
#glmdetection <- glm(presence ~ tempdaymean + I(tempdaymean^2), data=data, family="binomial")
glmdetection <- glm(presence ~ tempdaymean, data=data, family="binomial")
###predictions
rangex <- range(data$tempdaymean, na.rm=T)
#testx <- as.matrix(seq(min(rangex), max(rangex), 0.01))
testx <- as.matrix(seq(-4,4,0.1))
testy <- predict(glmdetection, list(tempdaymean = testx),type="response")
lines(testx * attr(data$tempdaymean, 'scaled:scale') + attr(data$tempdaymean, 'scaled:center'),testy,col="red",lty=2,lwd=2)

#add real data
points(data$tempdaymean * attr(data$tempdaymean, 'scaled:scale') + attr(data$tempdaymean, 'scaled:center'),data$presence,pch=16,col = adjustcolor(ifelse(data$presence > 0,'blue','red'),0.1))

#legend
legend("right", c("Presence","Absence","GLM","Mean Detection Probability","Min:Max Detection Probability"), col=c("blue","red","red","black",adjustcolor("green",0.3)),lty=c(NA,NA,2,1,NA),pch=c(16,16,NA,NA,15),bty="n")

```

# Bernd Presentation Plots
```{r, eval=FALSE}
posterior <- extract(stan.fit)
meanpsi_sim <- apply(posterior$psi_sim,2,mean)
#Parameters to test
#MELA
meanpardistance     <- mean(posterior$partopographyPreds[,4])
meanparelevation    <- mean(posterior$partopographyPreds[,2])
meanparslope        <- mean(posterior$partopographyPreds[,1])
meanparforest       <- mean(posterior$parlandcoverPreds[,1])
meanparurban        <- mean(posterior$parlandcoverPreds[,2])
meanparagriculture  <- mean(posterior$parlandcoverPreds[,3])
meanpargrass        <- mean(posterior$parlandcoverPreds[,4])
#PICTA
meanparSubalpinerFichtenwald <- mean(posterior$parforestPreds[,9])
meanparAuwald                <- mean(posterior$parforestPreds[,1])
meanparFichtentannenwald     <- mean(posterior$parforestPreds[,4])


results <- data.frame(data$fichtentannenwaelder,data$presence)
results <- results[order(results$data.fichtentannenwaelder), ] #reorder based on distance
plot(results$data.fichtentannenwaelder * attr(data$fichtentannenwaelder, 'scaled:scale') + attr(data$fichtentannenwaelder, 'scaled:center'),
     results$data.presence,
     xlab="Average spruce-fir forest area in 100m radius [m^2]",
     ylab="Observed presence",
     col=adjustcolor("black",0.5),
     ylim=c(0,1),
     pch="|",
     main="C.picta P-Generation")
lines(results$data.fichtentannenwaelder * attr(data$fichtentannenwaelder, 'scaled:scale') + attr(data$fichtentannenwaelder, 'scaled:center'),inv.logit(meanparFichtentannenwald*results$data.fichtentannenwaelder),col="red")
legend("right",c("Spruce-fir forest predictions"),col=c("red"),lty=1,bty="n")
```

# CHECKING IF MODEL ASSUMPTIONS ARE MET (UNIFORM DISPERSION)
```{r DHARMa Flight, eval=FALSE}
#for createDHARMa (experimental function)
#devtools::install_github(repo = "DHARMa", username = "florianhartig", subdir = "DHARMa", dependencies #= T)
library(DHARMa)

posterior <- extract(stan.fit, inc_warmup=F,permute=F) #extract all posterior w/o warmup

#for Stan Model
simulatedVector <- extract(stan.fit, 'simFlightPeriod_P', permuted=FALSE)
simulatedVector <- t(rbind(simulatedVector[,1,],simulatedVector[,2,],simulatedVector[,3,],simulatedVector[,4,]))


fittedVector <- extract(stan.fit, 'flightPeriod_P', permuted=FALSE)
fittedVector <- t(rbind(fittedVector[,1,],fittedVector[,2,],fittedVector[,3,],fittedVector[,4,]))
fittedVectorMean <- apply(fittedVector, 1 , median)


dharmastan <- createDHARMa(simulatedResponse = simulatedVector, observedResponse = data$amount, fittedPredictedResponse = fittedVectorMean, integerResponse = T)
#createDHARMa needs: scaled residuals OR all simulations + observations
plot(dharmastan)
```

```{r DHARMa Environment, eval=FALSE}
#for createDHARMa (experimental function)
#devtools::install_github(repo = "DHARMa", username = "florianhartig", subdir = "DHARMa", dependencies #= T)
library(DHARMa)

posterior <- extract(stan.fit, inc_warmup=F,permute=F) #extract all posterior w/o warmup

#for Stan Model
simulatedVector <- extract(stan.fit, 'simEnvironment_P', permuted=FALSE)
simulatedVector <- t(rbind(simulatedVector[,1,],simulatedVector[,2,],simulatedVector[,3,],simulatedVector[,4,]))
#simulatedVector <- t(matrix(simulatedVector, ncol = nrow(data)))

fittedVector <- extract(stan.fit, 'lambdaEnvironment_P', permuted=FALSE)
fittedVector <- t(rbind(fittedVector[,1,],fittedVector[,2,],fittedVector[,3,],fittedVector[,4,]))
fittedVectorMean <- apply(fittedVector, 1 , median)
#fittedVector <- matrix(fittedVector, ncol = nrow(data))
#fittedVectorMean <- apply(fittedVector, 2 , median)

dharmastan <- createDHARMa(simulatedResponse = simulatedVector, observedResponse = data$amount, fittedPredictedResponse = fittedVectorMean, integerResponse = T)
#createDHARMa needs: scaled residuals OR all simulations + observations
plot(dharmastan)
```

```{r DHARMa Detection, eval=FALSE}
#for createDHARMa (experimental function)
#devtools::install_github(repo = "DHARMa", username = "florianhartig", subdir = "DHARMa", dependencies #= T)
library(DHARMa)

posterior <- extract(stan.fit, inc_warmup=F,permute=F) #extract all posterior w/o warmup

#for Stan Model
simulatedVector <- extract(stan.fit, 'simDetection_P', permuted=FALSE)
simulatedVector <- t(rbind(simulatedVector[,1,],simulatedVector[,2,],simulatedVector[,3,],simulatedVector[,4,]))


fittedVector <- extract(stan.fit, 'pDetection_P', permuted=FALSE)
fittedVector <- t(rbind(fittedVector[,1,],fittedVector[,2,],fittedVector[,3,],fittedVector[,4,]))
fittedVectorMean <- apply(fittedVector, 1 , median)


dharmastan <- createDHARMa(simulatedResponse = simulatedVector, observedResponse = data$amount, fittedPredictedResponse = fittedVectorMean, integerResponse = T)
#createDHARMa needs: scaled residuals OR all simulations + observations
plot(dharmastan)
```

```{r DHARMa Population, eval=FALSE}
#for createDHARMa (experimental function)
#devtools::install_github(repo = "DHARMa", username = "florianhartig", subdir = "DHARMa", dependencies = T)
library(DHARMa)

posterior <- rstan::extract(stan.fit, inc_warmup=F,permute=F) #extract all posterior w/o warmup

#for Stan Model
simulatedVector <- rstan::extract(stan.fit, 'simPopulation_P', permuted=FALSE)
simulatedVector <- t(rbind(simulatedVector[,1,]))
#simulatedVector <- t(rbind(simulatedVector[,1,],simulatedVector[,2,],simulatedVector[,3,],simulatedVector[,4,]))
#simulatedVector <- t(matrix(simulatedVector, ncol = nrow(data)))

fittedVector <- rstan::extract(stan.fit, 'realAbundance_P', permuted=FALSE)
fittedVector <- t(rbind(fittedVector[,1,]))
#fittedVector <- t(rbind(fittedVector[,1,],fittedVector[,2,],fittedVector[,3,],fittedVector[,4,]))
fittedVectorMean <- apply(fittedVector, 1 , median)
#fittedVector <- matrix(fittedVector, ncol = nrow(data))
#fittedVectorMean <- apply(fittedVector, 2 , median)

dharmastan <- createDHARMa(simulatedResponse = simulatedVector, observedResponse = data$amount, fittedPredictedResponse = fittedVectorMean, integerResponse = T)
#createDHARMa needs: scaled residuals OR all simulations + observations
plot(dharmastan)
```

```{r Save Data}
#setwd("C:\\Users\\NSander\\Desktop\\AP") #for saving on server instead of local machine (e.g. when local machine is turned off)
save(dataList, stan.fit, file = paste("results/rstan/",today,"_CMELP.Rdata",sep=""))

save(
  data,
  # response
  
  # predictor matrix
  
  
  
  dataList,
  file = paste("results/rstan/",today,"_CMELP_DATA.Rdata",sep=""))
library(lattice)
trellis.device("pdf",
               file=paste("results/rstan/",today,"_CMELP_OUTPUT.pdf",sep=""),width=14, height=7)
plot(stan.fit)
dev.off()

```