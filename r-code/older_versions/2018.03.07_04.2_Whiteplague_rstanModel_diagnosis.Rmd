---*
title: "Environmental drivers of white plague disease on shallow and mesophotic coral reefs, U.S. Virgin Islands"
subtitel: "Residual diagnosis"
author: "Andia Chaves-Fonnegra, Bernd Panassiti, Tyler B. Smith, Elizabeth Brown, Elizabeth Clemens, Moriah Sevier, and Marilyn Brandt"
date: 'created: 25/07/2017, last modified: `r format(Sys.Date(), format="%d.%m.%Y")`'
output: pdf_document
---

```{r setup, include=FALSE, warnings=FALSE}
library(knitr)
opts_knit$set(root.dir='../')                     # definining working directory; or normalizePath('../')
opts_chunk$set(fig.align='center',                # aligns all figures
                echo=TRUE,                        # shows r-code
                message=FALSE,                    # suppresses library outputs
                warnings=FALSE,                   # suppresses library outputs
                tidy=TRUE,  # prevents the source code from running off a pdf page
                dev='pdf')                        # pdf device
```


# Environmental drivers of white plague disease on shallow and mesophotic coral reefs, U.S. Virgin Islands - Residual analysis

## Introduction
This document provides residual diagnosis for the logistic regression model using Bayesian inference for the White Plague disease on corals described in the article: ``Identifying local drivers of a vector-pathogen-disease system using Bayesian modeling''.
The Skript is based on the residuals analysis provided in Panassiti et al., 2016.

## Data






## Residual analysis


#### Loading data & libraries
```{r}
rm(list=ls(all=TRUE))
#NameOfModelRun <- "2018.03.01_Whiteplague_model_result_graphinput" # last environmental
NameOfModelRun <- "2018.02.28b_Whiteplague_model_result_graphinput" # last biological
load(file=paste("data/Extraction_diagnosis/",NameOfModelRun,".Rdata",sep=""))
load(file="data/Whiteplague_workingdata.Rdata")

#"devtools::install_github(repo = "DHARMa", username = "florianhartig", subdir = "DHARMa", dependencies = T, build_vignettes = TRUE)

library(DHARMa)
library(ggplot2)
library(lattice)
```


#### Create DHARMa object
```{r,echo=FALSE}
# Symptomatic corals - Response scale - inv.logit
WhitePlagueDHARMaResponse <- createDHARMa(simulatedResponse = simulatedPredictedWhitePlague,
  observedResponse = Whiteplague_workingdata_Annual$ill,fittedPredictedResponse = predictionsResponseMedianWhitePlague,integerResponse = T)
```


#### Plot DHARMa object
```{r}
plotSimulatedResiduals(simulationOutput = WhitePlagueDHARMaResponse)
```

###Test overdispersion
```{r}
#testOverdispersion(simulationOutput = WhitePlagueDHARMaResponse)
```
###Test zero inflation
```{r}
#testZeroInflation(WhitePlagueDHARMaResponse)
```




##Checking temporal autocorrelation with histograms and correlation plots 
```{r}
NameOfModelRun <- "2018.02.12a_Whiteplague_model_result"
load(file=paste("data/",NameOfModelRun,".Rdata",sep=""))

str(stan.white)
list_of_draws <- extract(stan.white)
print(names(list_of_draws))
head(list_of_draws$mu)

mu<- as.matrix(stan.white, pars = c("mu"))
head(mu)

#Following Chapter 23 "Incorporating Temporal Correlation.." In: Mixed Effects Models and Extensions in Ecology with R (2009) by Zuur, Ieno, Walker, Saveliev, Smith.

#to obtain Fig.23.6
mu.mean<-apply(mu,2,mean)
mu.sd<-apply(mu,2,sd)
hist(mu.mean)
hist(mu.sd)
mean(mu.sd^2)

#to obtain Fig.23.7

#Add a column with week.time or day time as in Seals



#This is from code
p.dist<-matrix(ncol=239,nrow=239)
for(i in 1:239) {
  for(j in 1:239) {
    p.dist[i,j]<-abs(Whiteplague_workingdata$Month_12[i]-Whiteplague_workingdata$Month_12[j])
  }
}
mu.cor<-cor(mu)
is.na(diag(mu.cor))<-T
hist(mu.cor)

plot(as.double(p.dist),as.double(mu.cor),main="Correlation against WeekTime difference",
     xlab="Month Time difference",ylab="Correlation",pch=20,cex=0.3) 

plot(as.double(p.dist[1:51,1:51]),as.double(p.eps.cor[1:51,1:51]),main="Correlation against WeekTime difference",
     xlab="WeekTime difference",ylab="Correlation",pch=20,cex=0.3) 

plot(as.double(p.dist[52:98,52:98]),as.double(p.eps.cor[52:98,52:98]),main="Correlation against WeekTime difference",
     xlab="WeekTime difference",ylab="Correlation",pch=20,cex=0.3) 


```

##Autocorrelation function ACF on residuals

```{r}
#Autocorrelation and partial autocorrelation plot of the residuals

de <- data.frame(scaledResiduals=WhitePlagueDHARMaResponse$scaledResiduals,x=Whiteplague_workingdata$Month_12, y=Whiteplague_workingdata$Year)



par(mfrow=c(1,2)) #set up two plots in one row
acf(WhitePlagueDHARMaResponse$scaledResiduals) #autocorrelation
acf((WhitePlagueDHARMaResponse$scaledResiduals), type="p") #partial autocorrelation
```

#Predictive maps of disease
#Figure 5. Standardized residuals (Bayesian p-values) for the two models of WP.


```{r}
library(maptools)
#crswgs84=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")


library(rgdal)     # R wrapper around GDAL/OGR
library(ggplot2)   # for general plotting
library(ggmap)    # for fortifying shapefiles

# First read in the shapefile, using the path to the shapefile and the shapefile name minus the
# extension as arguments
shapefile <- readOGR("data/GIS/", "tl_2015_78_estate_BP")
SHP_study_area <- shapefile

# Next the shapefile has to be converted to a dataframe for use in ggplot2
#SHP_study_area <- fortify(shapefile)


# Now the shapefile can be plotted as either a geom_path or a geom_polygon.
# Paths handle clipping better. Polygons can be filled.
# You need the aesthetics long, lat, and group.
# map <- ggplot() +
# geom_path(data = SHP_study_area, 
#           aes(x = long, y = lat, group = group),
#           color = 'gray', size = .2)+
# geom_point(aes(x = Whiteplague_workingdata_Annual$Longitude, y = Whiteplague_workingdata_Annual$Latitude) ,shape=23, fill="blue", color="darkred", size=3)
# #print(map)
# # Using the ggplot2 function coord_map will make things look better and it will also let you change
# # the projection. But sometimes with large shapefiles it makes everything blow up.
# map_projected <- map +
#   coord_map()
#   
# print(map_projected)
```



##### Observed incidenes per site
```{r Observed_incidences_site}
# # Farbcodierung
# Model = Data White
# Model > Daten Red (because if high it is more intuitive to make it red)
# Model < Data Blue

colFunc<-colorRampPalette(c("red","white","blue"))
colFuncBlueRed<-colFunc(10)



predictedWPPvalues <- list()
predictedWPPvalues[["scaledResiduals"]] <- WhitePlagueDHARMaResponse$scaledResiduals

n="scaledResiduals"
nObs=length(predictedWPPvalues[[n]])
            
predictedWPPvalues[["pointColor"]] <- rep(0,nObs)


pointColor<-NULL

for (i in 1:nObs){
  x<-predictedWPPvalues[[n]][i]
  if(x <=0.1){pointColor<-colFuncBlueRed[1]}
  if(x > 0.1 & x<=0.2){pointColor<-colFuncBlueRed[2]}
  if(x > 0.2 & x<=0.3){pointColor<-colFuncBlueRed[3]}
  if(x > 0.3 & x<=0.4){pointColor<-colFuncBlueRed[4]}
  if(x > 0.4 & x<=0.5){pointColor<-colFuncBlueRed[5]}
  if(x > 0.5 & x<=0.6){pointColor<-colFuncBlueRed[6]}
  if(x > 0.6 & x<=0.7){pointColor<-colFuncBlueRed[7]}
  if(x > 0.7 & x<=0.8){pointColor<-colFuncBlueRed[8]}
  if(x > 0.8 & x<=0.9){pointColor<-colFuncBlueRed[9]}
  if(x > 0.9 & x<=1  ){pointColor<-colFuncBlueRed[10]}
    predictedWPPvalues[["pointColor"]][i] <- pointColor

}
pointColors <- predictedWPPvalues[["pointColor"]]

set.seed(1)
#trellis.device("pdf",file=paste("figures/",today,"_rstan_WP_predictions_Annual.pdf",sep=""))
#dev.off()

# biological
x = Whiteplague_workingdata_Annual$Longitude
y = Whiteplague_workingdata_Annual$Latitude
plot(SHP_study_area,lwd = 0.1,main=paste("Bayesian p-values of Biological model"),ylim=c(18.18,18.348))
points(jitter(x,factor=40),y,col=pointColors,pch=19,cex=2)


# # environmental
# x = Whiteplague_workingdata$Longitude
# y = Whiteplague_workingdata$Latitude
# 
# plot(SHP_study_area,lwd = 0.1,main=paste("Bayesian p-values of Environmental model"),ylim=c(18.18,18.348))
# points(jitter(x,factor=40),jitter(y,factor=40),col=pointColors,pch=19,cex=2)

```




```{r}
x = Whiteplague_workingdata_Annual$Longitude
y = Whiteplague_workingdata_Annual$Latitude
df <- data.frame(x,y,values=WhitePlagueDHARMaResponse$scaledResiduals,sites=Whiteplague_workingdata_Annual$Station_code)

SHP_study_area_Fortified <- fortify(shapefile)


library("ggplot2")
library("maps")
library("grid")
library("gridExtra")

df2 <- df%>% group_by(site)

p1 <- ggplot() +
geom_path(data = SHP_study_area_Fortified, aes(x = long, y = lat, group = group),color = 'gray', size = .2)+
geom_point(data=df,aes(x = x, y = y,color=values, group=sites) ,shape=16,  size=6)+
  geom_path(lwd=20) +
  scale_color_continuous(low='blue', high='red', guide=F)+
theme_bw()+
coord_cartesian(ylim=c(18.16,18.42))

p1
```


```{r}
x = Whiteplague_workingdata_Annual$Longitude
y = Whiteplague_workingdata_Annual$Latitude
df <- data.frame(x,y,values=WhitePlagueDHARMaResponse$scaledResiduals,sites=Whiteplague_workingdata_Annual$Station_code)

SHP_study_area_Fortified <- fortify(shapefile)


library("ggplot2")
library("maps")
library("grid")
library("gridExtra")

df2 <- df%>% group_by(site)

p1 <- ggplot() +
geom_path(data = SHP_study_area_Fortified, aes(x = long, y = lat, group = group),color = 'gray', size = .2)+
#geom_point(data=df,aes(x = x, y = y) ,shape=23, fill="blue", color="darkred", size=3)+
#geom_boxplot(data=df, aes(x=x, y=y, stat = "identity",fill=factor(sites), group=sites))+
  theme_bw()+
coord_cartesian(xlim=c(-65.2,-64.5),ylim=c(18.14,18.42))




colFunc<-colorRampPalette(c("red","white","blue"))
colFuncBlueRed<-colFunc(10)




grid.newpage()
pushViewport(dataViewport(x, y, c(-65.2,-64.5), c(18.14,18.42)))
v1<-viewport(default.units = "native") #plot area for the main map
print(p1,vp=v1) 

for (i in 1:length(unique(df$sites))){
  dfSite <- df[df$sites %in% unique(df$sites)[i],]
  dfSite$values <- as.factor(dfSite$values)
  scaleColors <- list()
  scaleColors[["pointColor"]] <- rep(0,nrow(dfSite))
  
  for (j in 1:nrow(dfSite)){
  x<-as.numeric(as.character(dfSite$values[j]))
  if(x <=0.1){pointColor<-colFuncBlueRed[1]}
  if(x > 0.1 & x<=0.2){pointColor<-colFuncBlueRed[2]}
  if(x > 0.2 & x<=0.3){pointColor<-colFuncBlueRed[3]}
  if(x > 0.3 & x<=0.4){pointColor<-colFuncBlueRed[4]}
  if(x > 0.4 & x<=0.5){pointColor<-colFuncBlueRed[5]}
  if(x > 0.5 & x<=0.6){pointColor<-colFuncBlueRed[6]}
  if(x > 0.6 & x<=0.7){pointColor<-colFuncBlueRed[7]}
  if(x > 0.7 & x<=0.8){pointColor<-colFuncBlueRed[8]}
  if(x > 0.8 & x<=0.9){pointColor<-colFuncBlueRed[9]}
  if(x > 0.9 & x<=1  ){pointColor<-colFuncBlueRed[10]}
    scaleColors[["pointColor"]][j] <- pointColor

}
  
  colors=scaleColors[["pointColor"]]
  
p2 <- ggplot(data=dfSite,aes(x = 1, y=values,fill=values)) +
geom_tile(show.legend = FALSE,stat="identity") + 
scale_fill_manual(values=colors)+
  #scale_fill_gradient2(low = 'blue', mid = 'white', high = 'red', midpoint = 0.5) + 
  #theme_minimal()
  xlab("") + 
  ylab("") +
  theme(#panel.grid.major = element_blank(),
        #panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "none",
        axis.text.x= element_blank(),
        axis.text.y= element_blank(),
        panel.background = element_rect(fill = "transparent"), # bg of the panel
     plot.background = element_rect(fill = "transparent"), # bg of the plot
     panel.grid.major = element_blank(), # get rid of major grid
    panel.grid.minor = element_blank(), # get rid of minor grid
     legend.background = element_rect(fill = "transparent"), # get rid of legend bg
    legend.box.background = element_rect(fill = "transparent") # get rid of legend panel bg)
    )
    
v2<-viewport(width = 0.04, height = 0.04, x = dfSite$x[1], y = dfSite$y[1],default.units = "native") #plot area for the inset map

print(p2,vp=v2)
}

```






```{r}
x = Whiteplague_workingdata_Annual$Longitude
y = Whiteplague_workingdata_Annual$Latitude
df <- data.frame(x,y,values=WhitePlagueDHARMaResponse$scaledResiduals,sites=Whiteplague_workingdata_Annual$Station_code)

SHP_study_area_Fortified <- fortify(shapefile)


library("ggplot2")
library("maps")
library("grid")
library("gridExtra")

df2 <- df%>% group_by(site)

p1 <- ggplot() +
geom_path(data = SHP_study_area_Fortified, aes(x = long, y = lat, group = group),color = 'gray', size = .2)+
#geom_point(data=df,aes(x = x, y = y) ,shape=23, fill="blue", color="darkred", size=3)+
#geom_boxplot(data=df, aes(x=x, y=y, stat = "identity",fill=factor(sites), group=sites))+
  theme_bw()+
coord_cartesian(xlim=c(-65.2,-64.5),ylim=c(18.14,18.42))




vp <- dataViewport(xData = df$x, yData = df$y)


grid.newpage()
pushViewport(dataViewport(x, y, c(-65.2,-64.5), c(18.14,18.42)))
#pushViewport(dataViewport(x, y, c(0,1), c(0,1)))
v1<-viewport(default.units = "native") #plot area for the main map

print(p1,vp=v1) 

for (i in 1:length(unique(df$sites))){
  dfSite <- df[df$sites %in% unique(df$sites)[i],]
p2 <- ggplot(dfSite, aes(sites, values)) + geom_boxplot()+ 
  theme(
      axis.title=element_blank()
    ,  panel.background = element_rect(fill = "transparent") # bg of the panel
    , plot.background = element_rect(fill = "transparent") # bg of the plot
    , panel.grid.major = element_blank() # get rid of major grid
    , panel.grid.minor = element_blank() # get rid of minor grid
    , legend.background = element_rect(fill = "transparent") # get rid of legend bg
    , legend.box.background = element_rect(fill = "transparent") # get rid of legend panel bg
  )


v2<-viewport(width = 0.05, height = 0.05, x = dfSite$x[1], y = dfSite$y[1],default.units = "native") #plot area for the inset map

# 
# x=as.numeric(convertX( unit(dfSite$x[1],'native'),'npc'))
# 
# x=convertX( unit(dfSite$x[1],'native'),'npc',valueOnly=TRUE)
# valueOnly
# 
# y=as.numeric(convertX( unit(dfSite$y[1],'native'),'in'))
# v2<-viewport(width = 0.5, height = 0.5, x = x, y = y)

print(p2,vp=v2)

}



tmp <- grid.locator()
tmp.n <- as.numeric(tmp)
tmp2.x <- as.numeric(convertX( unit(x,'native'), 'in' ))
tmp2.y <- as.numeric(convertY( unit(y,'native'), 'in' ))

w <- which.min( (tmp2.x-tmp.n[1])^2 + (tmp2.y-tmp.n[2])^2 )
grid.text(w, tmp$x, tmp$y )



```







