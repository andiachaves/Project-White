---*
title: "Environmental drivers of white plague disease on shallow and mesophotic coral reefs, U.S. Virgin Islands"
subtitel: "Residual diagnosis"
author: "Andia Chaves-Fonnegra, Bernd Panassiti, Tyler B. Smith, Elizabeth Brown, Elizabeth Clemens, Moriah Sevier, and Marilyn Brandt"
date: 'created: 25/07/2017, last modified: `r format(Sys.Date(), format="%d.%m.%Y")`'
output: pdf_document
---

```{r setup, include=FALSE, warnings=FALSE}
library(knitr)
opts_knit$set(root.dir='../')                     # definining working directory; or normalizePath('../')
opts_chunk$set(fig.align='center',                # aligns all figures
                echo=TRUE,                        # shows r-code
                message=FALSE,                    # suppresses library outputs
                warnings=FALSE,                   # suppresses library outputs
                tidy=TRUE,  # prevents the source code from running off a pdf page
                dev='pdf')                        # pdf device
```


# Environmental drivers of white plague disease on shallow and mesophotic coral reefs, U.S. Virgin Islands - Residual analysis

## Introduction
This document provides residual diagnosis for the logistic regression model using Bayesian inference for the White Plague disease on corals described in the article: ``Identifying local drivers of a vector-pathogen-disease system using Bayesian modeling''.
The Skript is based on the residuals analysis provided in Panassiti et al., 2016.

## Data






## Residual analysis


#### Loading data & libraries
```{r}
rm(list=ls(all=TRUE))

NameOfModelRun <- "2018.02.27a_Whiteplague_model_result_graphinput"
load(file=paste("data/",NameOfModelRun,".Rdata",sep=""))
load(file="data/Whiteplague_workingdata.Rdata")

#"devtools::install_github(repo = "DHARMa", username = "florianhartig", subdir = "DHARMa", dependencies = T, build_vignettes = TRUE)

library(DHARMa)
```


#### Create DHARMa object
```{r,echo=FALSE}
# Symptomatic corals - Response scale - inv.logit
WhitePlagueDHARMaResponse <- createDHARMa(simulatedResponse = simulatedPredictedWhitePlague,
  observedResponse = Whiteplague_workingdata$ill,fittedPredictedResponse = predictionsResponseMedianWhitePlague,integerResponse = T)
```


#### Plot DHARMa object
```{r}
plotSimulatedResiduals(simulationOutput = WhitePlagueDHARMaResponse)
```

###Test overdispersion
```{r}
#testOverdispersion(simulationOutput = WhitePlagueDHARMaResponse)
```
###Test zero inflation
```{r}
#testZeroInflation(WhitePlagueDHARMaResponse)
```



#### Spatial autocorrelation
```{r}
#test Spatial autocorrelation Moran's I

# Problem repeating sites result in 0 distances!
library(dplyr)
df <- data.frame(scaledResiduals=WhitePlagueDHARMaResponse$scaledResiduals,x=Whiteplague_workingdata$Latitude,y=Whiteplague_workingdata$Longitude)

# 1 option - group and mean

dfNew <- as.data.frame(df %>%
  group_by(x, y) %>%
  summarize(scaledResiduals = mean(scaledResiduals, na.rm = TRUE)))

testSpatialAutocorrelation(simulationOutput = dfNew, x = dfNew$x,y = dfNew$y)

# 2. option - random noise
df$x_new <- rnorm(df$x,df$x,0.001)
df$y_new <- rnorm(df$y,df$y,0.001)

testSpatialAutocorrelation(simulationOutput = df, x = df$x_new,y = df$y_new)
```

Both tests indicate that we should reject the null of no spatial auto-correlation. There is spatial autocorrelation.

### Test for residuals temporal autocorrelation
```{r}
# test temporal autocorrelation Durbin-Watson test in the residuals
#Month
testTemporalAutocorrelation(simulationOutput = df, time = Whiteplague_workingdata$Month_12, plot=T)
#Year
testTemporalAutocorrelation(simulationOutput = df, time = Whiteplague_workingdata$Year, plot=T)
#Seasons
testTemporalAutocorrelation(simulationOutput = df, time = Whiteplague_workingdata$Season, plot=T)
#Time points
testTemporalAutocorrelation(simulationOutput = df, time = Whiteplague_workingdata$Time_point, plot=T)
#Random time
#testTemporalAutocorrelation(simulationOutput = df, time = "random")

#Same as.. Month
testTemporalAutocorrelation(simulationOutput= WhitePlagueDHARMaResponse, time = Whiteplague_workingdata$Month_12, plot=T)
```

##Checking temporal autocorrelation with histograms and correlation plots 
```{r}
NameOfModelRun <- "2018.02.12a_Whiteplague_model_result"
load(file=paste("data/",NameOfModelRun,".Rdata",sep=""))

str(stan.white)
list_of_draws <- extract(stan.white)
print(names(list_of_draws))
head(list_of_draws$mu)

mu<- as.matrix(stan.white, pars = c("mu"))
head(mu)

#Following Chapter 23 "Incorporating Temporal Correlation.." In: Mixed Effects Models and Extensions in Ecology with R (2009) by Zuur, Ieno, Walker, Saveliev, Smith.

#to obtain Fig.23.6
mu.mean<-apply(mu,2,mean)
mu.sd<-apply(mu,2,sd)
hist(mu.mean)
hist(mu.sd)
mean(mu.sd^2)

#to obtain Fig.23.7

#Add a column with week.time or day time as in Seals



#This is from code
p.dist<-matrix(ncol=239,nrow=239)
for(i in 1:239) {
  for(j in 1:239) {
    p.dist[i,j]<-abs(Whiteplague_workingdata$Month_12[i]-Whiteplague_workingdata$Month_12[j])
  }
}
mu.cor<-cor(mu)
is.na(diag(mu.cor))<-T
hist(mu.cor)

plot(as.double(p.dist),as.double(mu.cor),main="Correlation against WeekTime difference",
     xlab="Month Time difference",ylab="Correlation",pch=20,cex=0.3) 

plot(as.double(p.dist[1:51,1:51]),as.double(p.eps.cor[1:51,1:51]),main="Correlation against WeekTime difference",
     xlab="WeekTime difference",ylab="Correlation",pch=20,cex=0.3) 

plot(as.double(p.dist[52:98,52:98]),as.double(p.eps.cor[52:98,52:98]),main="Correlation against WeekTime difference",
     xlab="WeekTime difference",ylab="Correlation",pch=20,cex=0.3) 


```

##Autocorrelation function ACF on residuals

```{r}
#Autocorrelation and partial autocorrelation plot of the residuals

de <- data.frame(scaledResiduals=WhitePlagueDHARMaResponse$scaledResiduals,x=Whiteplague_workingdata$Month_12, y=Whiteplague_workingdata$Year)



par(mfrow=c(1,2)) #set up two plots in one row
acf(WhitePlagueDHARMaResponse$scaledResiduals) #autocorrelation
acf((WhitePlagueDHARMaResponse$scaledResiduals), type="p") #partial autocorrelation
```

#Predictive maps of disease
#Figure 5. Standardized residuals (Bayesian p-values) for the two models of WP.


```{r}
#Create list call predicted WPPvalues

predictedWPPvalues <- list()

predictedWPPvalues[["Month"]] <- WhitePlagueDHARMaResponse$scaledResiduals
#predictedWPPvalues[["Annual"]] <- pWhitePlagueDHARMaResponse$scaledResiduals

```



```{r}
# Model = Data White
# Model > Daten Red (because if high it is more intuitive to make it red)
# Model < Data Blue

#create a gradient from red to blue, the midle is white
colFunc<-colorRampPalette(c("red","white","blue"))
#This is to give 10 levels or categories to the color palete.
colFuncBlueRed<-colFunc(10)

#Create PDF figure

#Check plot(schriesheimTerrassen) This is the area bernd used, we need a map to plot first. We have a tiff Bathymetry map of the islands.

trellis.device("pdf",file=paste("figures/",today,"_rstan_WP_predictions.pdf",sep=""))
for (n in c("Month")){ # vector,monthly
 
  #Ignore histogram 
  
#hist(ecdfPredictions,xlim=range(c(0,1)),ylim=c(0,100),main=paste("predicted",n,sep=""))

  #First plot the map and then add the residuals for each site.
pointColor<-NULL
plot(bathymetry.tiff,lwd = 0.1,main=paste("predicted",n,sep=""))
#points(schriesheimTraps,pch=15,col="yellow"). 

#Number of sites (in our case is 13 sites)
#The scaled  residuals (p-values) of each site is assigned to each color 
for (i in 1:96){
  x<-predictedWPPvalues[[n]][i]
  if(x <=0.1){pointColor<-colFuncBlueRed[1]}
  if(x > 0.1 & x<=0.2){pointColor<-colFuncBlueRed[2]}
  if(x > 0.2 & x<=0.3){pointColor<-colFuncBlueRed[3]}
  if(x > 0.3 & x<=0.4){pointColor<-colFuncBlueRed[4]}
  if(x > 0.4 & x<=0.5){pointColor<-colFuncBlueRed[5]}
  if(x > 0.5 & x<=0.6){pointColor<-colFuncBlueRed[6]}
  if(x > 0.6 & x<=0.7){pointColor<-colFuncBlueRed[7]}
  if(x > 0.7 & x<=0.8){pointColor<-colFuncBlueRed[8]}
  if(x > 0.8 & x<=0.9){pointColor<-colFuncBlueRed[9]}
  if(x > 0.9 & x<=1  ){pointColor<-colFuncBlueRed[10]}
  #This add the point color to the coordinates, add sites coordinates and x and y.
  points(trapCoords$st_x[i],trapCoords$st_y[i],col=pointColor,pch=19,cex=2)
}
}
dev.off()
```



